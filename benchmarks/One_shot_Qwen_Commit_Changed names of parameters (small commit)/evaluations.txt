Loaded 164 samples from completions_rust_humanevalsynthesize_parsed.jsonl

Testing Rust/0 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{
let mut sorted_numbers = numbers.clone();
    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());

    for window in sorted_numbers.windows(2) {
        if let [a, b] = window {
            if (a - b).abs() < threshold {
                return true;
            }
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_has_close_elements() {
        assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);
        assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);
        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);
        assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/1 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn separate_paren_groups(paren_string: String) -> Vec<String>{
let mut result = Vec::new();
    let mut current_group = String::new();
    let mut balance = 0;

    for c in paren_string.chars() {
        if c == ' ' {
            continue; // Ignore spaces
        }
        current_group.push(c);
        if c == '(' {
            balance += 1;
        } else if c == ')' {
            balance -= 1;
        }
        if balance == 0 && !current_group.is_empty() {
            result.push(current_group.clone());
            current_group.clear();
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_separate_paren_groups() {
        assert_eq!(
            separate_paren_groups(String::from("(()()) ((())) () ((())()())")),
            vec!["(()())", "((()))", "()", "((())()())"]
        );
        assert_eq!(
            separate_paren_groups(String::from("() (()) ((())) (((())))")),
            vec!["()", "(())", "((()))", "(((())))"]
        );
        assert_eq!(
            separate_paren_groups(String::from("(()(())((())))")),
            vec!["(()(())((())))"]
        );
        assert_eq!(
            separate_paren_groups(String::from("( ) (( )) (( )( ))")),
            vec!["()", "(())", "(()())"]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/2 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn truncate_number(number: &f32) -> f32{
number - number.floor()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_truncate_number() {
        assert_eq!(truncate_number(&3.5), 0.5);
        let t1: f32 = 1.33 - 0.33;
        assert!(truncate_number(&t1) < 0.000001);
        let t2: f32 = 123.456 - 0.456;
        assert!(truncate_number(&t2) < 0.000001);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/3 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn below_zero(operations:Vec<i32>) -> bool{
let mut balance = 0;
    for operation in operations {
        balance += operation;
        if balance < 0 {
            return true;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_below_zero() {
        assert_eq!(below_zero(vec![]), false);
        assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);
        assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);
        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);
        assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);
        assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/4 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{
if numbers.is_empty() {
        return 0.0;
    }

    // Calculate the mean of the numbers
    let sum: f32 = numbers.iter().sum();
    let mean = sum / numbers.len() as f32;

    // Calculate the mean absolute deviation
    let mad: f32 = numbers.iter().map(|&x| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;

    mad
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_mean_absolute_deviation() {
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);
        assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/5 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn intersperse(numbers:Vec<u32>, delimeter: u32) -> Vec<u32>{
if numbers.is_empty() {
        return numbers;
    }

    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);
    let mut iter = numbers.into_iter();

    if let Some(first) = iter.next() {
        result.push(first);
        for num in iter {
            result.push(delimiter);
            result.push(num);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_intersperse() {
        assert!(intersperse(vec![], 7) == vec![]);
        assert!(intersperse(vec![5, 6, 3, 2], 8) == vec![5, 8, 6, 8, 3, 8, 2]);
        assert!(intersperse(vec![2, 2, 2], 2) == vec![2, 2, 2, 2, 2]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_5_gen0.jsonl

Testing Rust/6 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn parse_nested_parens(paren_string:String) -> Vec<i32>{
paren_string.split_whitespace().map(|group| {
        let mut max_depth = 0;
        let mut current_depth = 0;
        
        for c in group.chars() {
            match c {
                '(' => {
                    current_depth += 1;
                    max_depth = cmp::max(max_depth, current_depth);
                }
                ')' => {
                    current_depth -= 1;
                }
                _ => {}
            }
        }
        
        max_depth
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_parse_nested_parens() {
        assert!(
            parse_nested_parens(String::from("(()()) ((())) () ((())()())")) == vec![2, 3, 1, 3]
        );
        assert!(parse_nested_parens(String::from("() (()) ((())) (((())))")) == vec![1, 2, 3, 4]);
        assert!(parse_nested_parens(String::from("(()(())((())))")) == vec![4]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/7 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_by_substring(strings: Vec<String>, substring:String) -> Vec<String>{
strings.into_iter().filter(|s| s.contains(&substring)).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_filter_by_substring() {
        let v_empty: Vec<String> = vec![];
        assert!(filter_by_substring(vec![], String::from("john")) == v_empty);
        assert!(
            filter_by_substring(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "xxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                String::from("xxx")
            ) == vec!["xxx", "xxxAAA", "xxx"]
        );
        assert!(
            filter_by_substring(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "aaaxxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                String::from("xx")
            ) == vec!["xxx", "aaaxxy", "xxxAAA", "xxx"]
        );
        assert!(
            filter_by_substring(
                vec![
                    "grunt".to_string(),
                    "trumpet".to_string(),
                    "prune".to_string(),
                    "gruesome".to_string()
                ],
                String::from("run")
            ) == ["grunt", "prune"]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/8 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_product(numbers:Vec<i32>) -> (i32,i32){
let sum: i32 = numbers.iter().sum();
    let product: i32 = numbers.iter().fold(1, |acc, &x| acc * x);
    (sum, product)
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sum_product() {
        assert!(sum_product(vec![]) == (0, 1));
        assert!(sum_product(vec![1, 1, 1]) == (3, 1));
        assert!(sum_product(vec![100, 0]) == (100, 0));
        assert!(sum_product(vec![3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7));
        assert!(sum_product(vec![10]) == (10, 10));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/9 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rolling_max(numbers:Vec<i32>) -> Vec<i32>{
let mut result = Vec::new();
    let mut current_max = i32::MIN;

    for &number in &numbers {
        current_max = cmp::max(current_max, number);
        result.push(current_max);
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_rolling_max() {
        assert!(rolling_max(vec![]) == vec![]);
        assert!(rolling_max(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);
        assert!(rolling_max(vec![4, 3, 2, 1]) == vec![4, 4, 4, 4]);
        assert!(rolling_max(vec![3, 2, 3, 100, 3]) == vec![3, 3, 3, 100, 100]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/10 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_palindrome_10(str: &str) -> bool {
        let s: String = str.chars().rev().collect();
        return s==str;
    }

fn make_palindrome(str: &str) -> String {
if s.is_empty() {
        return s.to_string();
    }

    // Find the longest palindromic suffix
    let mut longest_palindromic_suffix_length = 0;
    for i in 0..s.len() {
        if is_palindrome(&s[i..]) {
            longest_palindromic_suffix_length = s.len() - i;
            break;
        }
    }

    // The prefix that needs to be reversed and appended
    let prefix_to_reverse = &s[..s.len() - longest_palindromic_suffix_length];
    let reversed_prefix: String = prefix_to_reverse.chars().rev().collect();

    // Construct the shortest palindrome
    format!("{}{}", s, reversed_prefix)
}

fn is_palindrome(s: &str) -> bool {
    let s: String = s.chars().rev().collect();
    s == s
}





fn is_palindrome(s: &str) -> bool {
    let chars: Vec<char> = s.chars().collect();
    let len = chars.len();
    for i in 0..len / 2 {
        if chars[i] != chars[len - 1 - i] {
            return false;
        }
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_make_palindrome() {
        assert_eq!(make_palindrome(""), "");
        assert_eq!(make_palindrome("x"), "x");
        assert_eq!(make_palindrome("xyz"), "xyzyx");
        assert_eq!(make_palindrome("xyx"), "xyx");
        assert_eq!(make_palindrome("jerry"), "jerryrrej");
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_10_gen0.jsonl

Testing Rust/11 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_xor(a:String, b:String) -> String{
// Ensure both strings are of the same length by padding the shorter one with leading zeros
    let max_len = a.len().max(b.len());
    let a_padded = format!("{:0>width$}", a, width = max_len);
    let b_padded = format!("{:0>width$}", b, width = max_len);

    // Perform XOR operation character by character
    let mut result = String::with_capacity(max_len);
    for (char_a, char_b) in a_padded.chars().zip(b_padded.chars()) {
        let xor_char = if char_a == char_b { '0' } else { '1' };
        result.push(xor_char);
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_string_xor() {
        assert!(string_xor("111000".to_string(), "101010".to_string()) == "010010");
        assert!(string_xor("1".to_string(), "1".to_string()) == "0");
        assert!(string_xor("0101".to_string(), "0000".to_string()) == "0101");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/12 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn longest(strings:Vec<String>) -> Option<String>{

strings.into_iter().max_by_key(|s| s.len())
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_longest() {
        assert!(longest(vec![]) == None);
        assert!(
            longest(vec!["x".to_string(), "y".to_string(), "z".to_string()])
                == Some("x".to_string())
        );
        assert!(
            longest(vec![
                "x".to_string(),
                "yyy".to_string(),
                "zzzz".to_string(),
                "www".to_string(),
                "kkkk".to_string(),
                "abc".to_string()
            ]) == Some("zzzz".to_string())
        );
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_12_gen0.jsonl

Testing Rust/13 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn greatest_common_divisor(mut a:i32,mut b:i32) -> i32{

while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_greatest_common_divisor() {
        assert!(greatest_common_divisor(3, 7) == 1);
        assert!(greatest_common_divisor(10, 15) == 5);
        assert!(greatest_common_divisor(49, 14) == 7);
        assert!(greatest_common_divisor(144, 60) == 12);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/14 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn all_prefixes(string: String) -> Vec<String>{

let mut prefixes = Vec::new();
    for i in 1..=string.len() {
        prefixes.push(string[0..i].to_string());
    }
    prefixes
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_all_prefixes() {
        let v_empty: Vec<String> = vec![];
        assert!(all_prefixes(String::from("")) == v_empty);
        assert!(
            all_prefixes(String::from("asdfgh"))
                == vec!["a", "as", "asd", "asdf", "asdfg", "asdfgh"]
        );
        assert!(all_prefixes(String::from("WWW")) == vec!["W", "WW", "WWW"]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/15 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_sequence(n:i32) -> String{

(0..=n).map(|i| i.to_string()).collect::<Vec<String>>().join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_string_sequence() {
        assert!(string_sequence(0) == "0".to_string());
        assert!(string_sequence(3) == "0 1 2 3".to_string());
        assert!(string_sequence(10) == "0 1 2 3 4 5 6 7 8 9 10".to_string());
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/16 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_distinct_characters(str:String) -> i32{

let mut unique_chars = HashSet::new();

    for c in s.chars() {
        if c != '`' {
            unique_chars.insert(c.to_ascii_lowercase());
        }
    }

    unique_chars.len() as i32
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_count_distinct_characters() {
        assert!(count_distinct_characters("".to_string()) == 0);
        assert!(count_distinct_characters("abcde".to_string()) == 5);
        assert!(
            count_distinct_characters(
                "abcde".to_string() + &"cade".to_string() + &"CADE".to_string()
            ) == 5
        );
        assert!(count_distinct_characters("aaaaAAAAaaaa".to_string()) == 1);
        assert!(count_distinct_characters("Jerry jERRY JeRRRY".to_string()) == 5);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_16_gen0.jsonl

Testing Rust/17 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn parse_music(music_string:String) -> Vec<i32>{

// Split the input string by the delimiter that separates notes
    let notes = music_string.split('|').collect::<Vec<&str>>();
    
    // Map each note to its corresponding beat value
    let mut beats = Vec::new();
    let mut i = 0;
    while i < notes.len() {
        let note = notes[i];
        if note == "o" {
            // Check if the next note is an empty string, which means it's a whole note 'o'
            if i + 1 < notes.len() && notes[i + 1].is_empty() {
                beats.push(4);
                i += 2; // Skip the next empty string
            } else {
                beats.push(2); // It's a half note 'o|'
                i += 1;
            }
        } else if note == "." {
            beats.push(1); // It's a quarter note '.|'
            i += 1;
        } else {
            i += 1; // Skip any unrecognized patterns
        }
    }
    
    beats
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_parse_music() {
        assert!(parse_music(" ".to_string()) == []);
        assert!(parse_music("o o o o".to_string()) == vec![4, 4, 4, 4]);
        assert!(parse_music(".| .| .| .|".to_string()) == vec![1, 1, 1, 1]);
        assert!(parse_music("o| o| .| .| o o o o".to_string()) == vec![2, 2, 1, 1, 4, 4, 4, 4]);
        assert!(parse_music("o| .| o| .| o o| o o|".to_string()) == vec![2, 1, 2, 1, 4, 2, 4, 2]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_17_gen0.jsonl

Testing Rust/18 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn how_many_times(string: String, substring:String) -> i32{

if substring.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut start = 0;
    let string_len = string.len();
    let substring_len = substring.len();

    while start <= string_len - substring_len {
        if &string[start..start + substring_len] == substring {
            count += 1;
        }
        start += 1;
    }

    count
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_how_many_times() {
        assert!(how_many_times("".to_string(), "x".to_string()) == 0);
        assert!(how_many_times("xyxyxyx".to_string(), "x".to_string()) == 4);
        assert!(how_many_times("cacacacac".to_string(), "cac".to_string()) == 4);
        assert!(how_many_times("john doe".to_string(), "john".to_string()) == 1);
    }


}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_18_gen0.jsonl

Testing Rust/19 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_numbers(numbers:String) -> String {

// Mapping from number words to their corresponding integer values
    let number_map: HashMap<&str, i32> = [
        ("zero", 0),
        ("one", 1),
        ("two", 2),
        ("three", 3),
        ("four", 4),
        ("five", 5),
        ("six", 6),
        ("seven", 7),
        ("eight", 8),
        ("nine", 9),
    ]
    .iter()
    .cloned()
    .collect();

    // Reverse mapping from integer values to their corresponding number words
    let reverse_number_map: HashMap<i32, &str> = number_map.iter().map(|(&k, &v)| (v, k)).collect();

    // Split the input string into words
    let words: Vec<&str> = numbers.split_whitespace().collect();

    // Convert words to their corresponding integer values
    let mut nums: Vec<i32> = words.iter().map(|&word| number_map[word]).collect();

    // Sort the integer values
    nums.sort();

    // Convert sorted integer values back to their string representations
    let sorted_words: Vec<&str> = nums.iter().map(|&num| reverse_number_map[num]).collect();

    // Join the sorted string representations into a single space-delimited string
    sorted_words.join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_sort_numbers() {
        assert!(sort_numbers("".to_string()) == "".to_string());
        assert!(sort_numbers("three".to_string()) == "three".to_string());
        assert!(sort_numbers("three five nine".to_string()) == "three five nine");
        assert!(
            sort_numbers("five zero four seven nine eight".to_string())
                == "zero four five seven eight nine".to_string()
        );
        assert!(
            sort_numbers("six five four three two one zero".to_string())
                == "zero one two three four five six".to_string()
        );
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_19_gen0.jsonl

Testing Rust/20 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn find_closest_elements(numbers:Vec<f32>) -> (f32,f32){

if numbers.len() < 2 {
        panic!("The list must contain at least two numbers.");
    }

    let mut sorted_numbers = numbers.clone();
    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());

    let mut closest_pair = (sorted_numbers[0], sorted_numbers[1]);
    let mut min_diff = (sorted_numbers[1] - sorted_numbers[0]).abs();

    for window in sorted_numbers.windows(2) {
        let diff = (window[1] - window[0]).abs();
        if diff < min_diff {
            min_diff = diff;
            closest_pair = (window[0], window[1]);
        }
    }

    closest_pair
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_find_closest_elements() {
        assert!(find_closest_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0));
        assert!(find_closest_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9));
        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2));
        assert!(find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0));
        assert!(find_closest_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/21 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rescale_to_unit(numbers:Vec<f32>) -> Vec<f32> {

if numbers.len() < 2 {
        panic!("The list must contain at least two elements.");
    }

    let min_value = numbers.iter().cloned().fold(f32::INFINITY, f32::min);
    let max_value = numbers.iter().cloned().fold(f32::NEG_INFINITY, f32::max);

    if min_value == max_value {
        panic!("All numbers in the list are the same.");
    }

    numbers.into_iter()
        .map(|x| (x - min_value) / (max_value - min_value))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_rescale_to_unit() {
        assert!(rescale_to_unit(vec![2.0, 49.9]) == [0.0, 1.0]);
        assert!(rescale_to_unit(vec![100.0, 49.9]) == [1.0, 0.0]);
        assert!(rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);
        assert!(rescale_to_unit(vec![2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);
        assert!(rescale_to_unit(vec![12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/22 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {

values.into_iter()
        .filter_map(|value| value.downcast::<i32>().ok())
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_filter_integers() {
        assert_eq!(filter_integers(vec![]), vec![]);
        let v_empty: Vec<Box<dyn Any>> = vec![];
        assert_eq!(
            filter_integers(vec![
                Box::new(4),
                Box::new(v_empty),
                Box::new(23.2),
                Box::new(9),
                Box::new(String::from("adasd"))
            ]),
            vec![4, 9]
        );
        assert_eq!(
            filter_integers(vec![
                Box::new(3),
                Box::new('c'),
                Box::new(3),
                Box::new(3),
                Box::new('a'),
                Box::new('b')
            ]),
            vec![3, 3, 3]
        );
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_22_gen0.jsonl

Testing Rust/23 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strlen(strings:String) -> i32{

strings.len() as i32
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_strlen() {
        assert!(strlen("".to_string()) == 0);
        assert!(strlen("x".to_string()) == 1);
        assert!(strlen("asdasnakj".to_string()) == 9);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/24 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_divisor(n:i32) -> i32{

if n <= 1 {
        return 0; // No divisors smaller than n for n <= 1
    }
    for i in (1..n).rev() {
        if n % i == 0 {
            return i;
        }
    }
    1 // This line is theoretically unreachable for n > 1
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_largest_divisor() {
        assert!(largest_divisor(3) == 1);
        assert!(largest_divisor(7) == 1);
        assert!(largest_divisor(10) == 5);
        assert!(largest_divisor(100) == 50);
        assert!(largest_divisor(49) == 7);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/25 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn factorize(n: i32) -> Vec<i32> {

let mut factors = Vec::new();
    let mut num = n;
    let mut divisor = 2;

    while num > 1 {
        while num % divisor == 0 {
            factors.push(divisor);
            num /= divisor;
        }
        divisor += 1;
    }

    factors
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_factorize() {
        assert_eq!(factorize(2), vec![2]);
        assert_eq!(factorize(4), vec![2, 2]);
        assert_eq!(factorize(8), vec![2, 2, 2]);
        assert_eq!(factorize(3 * 19), vec![3, 19]);
        assert_eq!(factorize(3 * 19 * 3 * 19), vec![3, 3, 19, 19]);
        assert_eq!(
            factorize(3 * 19 * 3 * 19 * 3 * 19),
            vec![3, 3, 3, 19, 19, 19]
        );
        assert_eq!(factorize(3 * 19 * 19 * 19), vec![3, 19, 19, 19]);
        assert_eq!(factorize(3 * 2 * 3), vec![2, 3, 3]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/26 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{

use std::collections::HashMap;

    // Create a HashMap to count occurrences of each number
    let mut counts = HashMap::new();
    for &number in &numbers {
        *counts.entry(number).or_insert(0) += 1;
    }

    // Filter the numbers to include only those that occur exactly once
    numbers.into_iter().filter(|&number| counts[&number] == 1).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_remove_duplicates() {
        assert!(remove_duplicates(vec![]) == []);
        assert!(remove_duplicates(vec![1, 2, 3, 4]) == vec![1, 2, 3, 4]);
        assert!(remove_duplicates(vec![1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/27 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

pub fn flip_case(string: String) -> String{

string.chars().map(|c| {
        if c.is_lowercase() {
            c.to_ascii_uppercase()
        } else if c.is_uppercase() {
            c.to_ascii_lowercase()
        } else {
            c
        }
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_flip_case() {
        assert!(flip_case("".to_string()) == "".to_string());
        assert!(flip_case("Hello!".to_string()) == "hELLO!".to_string());
        assert!(
            flip_case("These violent delights have violent ends".to_string())
                == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS".to_string()
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/28 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn concatenate(strings:Vec<String>) -> String{

strings.concat()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_concatenate() {
        assert!(concatenate(vec![]) == "".to_string());
        assert!(
            concatenate(vec!["x".to_string(), "y".to_string(), "z".to_string()])
                == "xyz".to_string()
        );
        assert!(
            concatenate(vec![
                "x".to_string(),
                "y".to_string(),
                "z".to_string(),
                "w".to_string(),
                "k".to_string()
            ]) == "xyzwk".to_string()
        );
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/29 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn filter_by_prefix(strings:Vec<String>, prefix:String)-> Vec<String>{

strings.into_iter().filter(|s| s.starts_with(&prefix)).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_filter_by_prefix() {
        let v_empty: Vec<String> = vec![];
        assert!(filter_by_prefix(vec![], "john".to_string()) == v_empty);
        assert!(
            filter_by_prefix(
                vec![
                    "xxx".to_string(),
                    "asd".to_string(),
                    "xxy".to_string(),
                    "john doe".to_string(),
                    "xxxAAA".to_string(),
                    "xxx".to_string()
                ],
                "xxx".to_string()
            ) == vec!["xxx", "xxxAAA", "xxx"]
        );
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/30 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_positive(numbers:Vec<i32>) -> Vec<i32>{

numbers.into_iter().filter(|&x| x > 0).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_get_positive() {
        assert!(get_positive(vec![-1, -2, 4, 5, 6]) == [4, 5, 6]);
        assert!(
            get_positive(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
        );
        assert!(get_positive(vec![-1, -2]) == []);
        assert!(get_positive(vec![]) == []);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/31 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_prime(n:i32) -> bool{

if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_prime() {
        assert!(is_prime(6) == false);
        assert!(is_prime(101) == true);
        assert!(is_prime(11) == true);
        assert!(is_prime(13441) == true);
        assert!(is_prime(61) == true);
        assert!(is_prime(4) == false);
        assert!(is_prime(1) == false);
        assert!(is_prime(5) == true);
        assert!(is_prime(11) == true);
        assert!(is_prime(17) == true);
        assert!(is_prime(5 * 17) == false);
        assert!(is_prime(11 * 7) == false);
        assert!(is_prime(13441 * 19) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/32 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn poly(xs: &Vec<f64>, x: f64) -> f64 {
        let mut sum = 0.0;
        for i in 0..xs.len() {
            sum += xs[i] * x.powi(i as i32);
        }
        sum
    }
    
    fn find_zero(xs: &Vec<f64>) -> f64 {
assert!(xs.len() % 2 == 0, "The number of coefficients must be even.");
    
    // Find an interval [a, b] such that poly(a) and poly(b) have opposite signs
    let mut a = -1.0;
    let mut b = 1.0;
    let tolerance = 1e-7;
    
    // Expand the interval if necessary
    while poly(xs, a) * poly(xs, b) > 0.0 {
        a *= 2.0;
        b *= 2.0;
    }
    
    // Bisection method
    while (b - a).abs() > tolerance {
        let c = (a + b) / 2.0;
        if poly(xs, c) == 0.0 {
            return c;
        } else if poly(xs, a) * poly(xs, c) < 0.0 {
            b = c;
        } else {
            a = c;
        }
    }
    
    (a + b) / 2.0
}

fn poly(xs: &Vec<f64>, x: f64) -> f64 {
    let mut sum = 0.0;
    for i in 0..xs.len() {
        sum += xs[i] * x.powi(i as i32);
    }
    sum
}






#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_poly() {
        let mut rng = rand::thread_rng();
        let mut solution: f64;
        let mut ncoeff: i32;
        for _ in 0..100 {
            ncoeff = 2 * (1 + rng.gen_range(0, 4));
            let mut coeffs = vec![];
            for _ in 0..ncoeff {
                let coeff = -10 + rng.gen_range(0, 21);
                if coeff == 0 {
                    coeffs.push(1.0);
                } else {
                    coeffs.push(coeff as f64);
                }
            }
            solution = find_zero(&coeffs);
            assert!(poly(&coeffs, solution).abs() < 1e-3);
        }
    }

}


-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_32_gen0.jsonl

Testing Rust/33 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_third(l: Vec<i32>) -> Vec<i32> {

// Collect elements at indices divisible by 3
    let mut divisible_by_three: Vec<i32> = l.iter().enumerate()
        .filter_map(|(i, &x)| if i % 3 == 0 { Some(x) } else { None })
        .collect();
    
    // Sort the collected elements
    divisible_by_three.sort();
    
    // Create a new vector to store the result
    let mut result = l.clone();
    
    // Replace elements at indices divisible by 3 with sorted elements
    let mut sorted_iter = divisible_by_three.into_iter();
    for (i, x) in result.iter_mut().enumerate() {
        if i % 3 == 0 {
            *x = sorted_iter.next().unwrap();
        }
    }
    
    result
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sort_third() {
        let mut l = vec![1, 2, 3];
        assert_eq!(sort_third(l), vec![1, 2, 3]);
        l = vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10];
        assert_eq!(sort_third(l), vec![5, 3, -5, 1, -3, 3, 2, 0, 123, 9, -10]);
        l = vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10];
        assert_eq!(sort_third(l), vec![5, 8, -12, -10, 23, 2, 3, 11, 12, 4]);
        l = vec![5, 6, 3, 4, 8, 9, 2];
        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4]);
        l = vec![5, 8, 3, 4, 6, 9, 2];
        assert_eq!(sort_third(l), vec![5, 8, 3, 2, 6, 9, 4]);
        l = vec![5, 6, 9, 4, 8, 3, 2];
        assert_eq!(sort_third(l), vec![5, 6, 9, 2, 8, 3, 4]);
        l = vec![5, 6, 3, 4, 8, 9, 2, 1];
        assert_eq!(sort_third(l), vec![5, 6, 3, 2, 8, 9, 4, 1]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_33_gen0.jsonl

Testing Rust/34 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn unique(nmbs:Vec<i32>)  -> Vec<i32>{

// Use a HashSet to filter out duplicates
    let mut unique_numbers: HashSet<i32> = HashSet::new();
    for n in nmbs {
        unique_numbers.insert(n);
    }

    // Convert the HashSet back to a Vec and sort it
    let mut result: Vec<i32> = unique_numbers.into_iter().collect();
    result.sort();

    result
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_unique() {
        assert!(unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]) == vec![0, 2, 3, 5, 9, 123]);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/35 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn maximum(nmbs:Vec<i32>) -> i32{

if nmbs.is_empty() {
        panic!("The list is empty");
    }
    *nmbs.iter().max().unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_maximum() {
        assert!(maximum(vec![1, 2, 3]) == 3);
        assert!(maximum(vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/36 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fizz_buzz(n:i32) -> i32{

let mut count = 0;
    for i in 1..n {
        if i % 11 == 0 || i % 13 == 0 {
            count += i.to_string().matches('7').count() as i32;
        }
    }
    count
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_fizz_buzz() {
        assert!(fizz_buzz(50) == 0);
        assert!(fizz_buzz(78) == 2);
        assert!(fizz_buzz(79) == 3);
        assert!(fizz_buzz(100) == 3);
        assert!(fizz_buzz(200) == 6);
        assert!(fizz_buzz(4000) == 192);
        assert!(fizz_buzz(10000) == 639);
        assert!(fizz_buzz(100000) == 8026);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/37 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_even(nmbs:Vec<i32>) -> Vec<i32>{

// Collect elements at even indices
    let mut even_elements: Vec<i32> = nmbs.iter().enumerate()
        .filter_map(|(i, &x)| if i % 2 == 0 { Some(x) } else { None })
        .collect();
    
    // Sort the even elements
    even_elements.sort();
    
    // Create a new vector to store the result
    let mut result = nmbs.clone();
    
    // Replace the even indices in the result vector with the sorted even elements
    let mut even_iter = even_elements.into_iter();
    for (i, x) in result.iter_mut().enumerate() {
        if i % 2 == 0 {
            *x = even_iter.next().unwrap();
        }
    }
    
    result
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_sort_even() {
        assert_eq!(sort_even(vec![1, 2, 3]), vec![1, 2, 3]);
        assert_eq!(
            sort_even(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),
            vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]
        );
        assert_eq!(
            sort_even(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),
            vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/38 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

pub fn encode_cyclic(s: &str) -> String {
    // returns encoded string by cycling groups of three characters.
    // split string to groups. Each of length 3.
    let l = s.len();
    let num = (l + 2) / 3;
    let mut output = String::new();
    for i in 0..num {
        let group = &s[i * 3..std::cmp::min(l, (i + 1) * 3)];
        // cycle elements in each group. Unless group has fewer elements than 3.
        if group.len() == 3 {
            let x = format!("{}{}{}", &group[1..2], &group[2..3], &group[0..1]);
            output.push_str(&x);
        } else {
            output.push_str(group);
        }
    }
    output
}

fn decode_cyclic(s: &str) -> String {

let l = s.len();
    let num = (l + 2) / 3;
    let mut output = String::new();
    for i in 0..num {
        let group = &s[i * 3..std::cmp::min(l, (i + 1) * 3)];
        // reverse cycle elements in each group. Unless group has fewer elements than 3.
        if group.len() == 3 {
            let x = format!("{}{}{}", &group[2..3], &group[0..1], &group[1..2]);
            output.push_str(&x);
        } else {
            output.push_str(group);
        }
    }
    output
}

fn encode_cyclic(s: &str) -> String {
    // returns encoded string by cycling groups of three characters.
    // split string to groups. Each of length 3.
    let l = s.len();
    let num = (l + 2) / 3;
    let mut output = String::new();
    for i in 0..num {
        let group = &s[i * 3..std::cmp::min(l, (i + 1) * 3)];
        // cycle elements in each group. Unless group has fewer elements than 3.
        if group.len() == 3 {
            let x = format!("{}{}{}", &group[1..2], &group[2..3], &group[0..1]);
            output.push_str(&x);
        } else {
            output.push_str(group);
        }
    }
    output
}





#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_decode_cyclic() {
        for _ in 0..100 {
            let l = 10 + rand::random::<u32>() % 11;
            let mut str = String::new();
            for _ in 0..l {
                let chr = 97 + rand::random::<u32>() % 26;
                str.push(chr as u8 as char);
            }
            let encoded_str = encode_cyclic(&str);
            assert_eq!(decode_cyclic(&encoded_str), str);
        }
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_38_gen0.jsonl

Testing Rust/39 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prime_fib(n: i32) -> i32 {

let mut count = 0;
    let mut a = 0;
    let mut b = 1;

    loop {
        let next_fib = a + b;
        a = b;
        b = next_fib;

        if is_prime(next_fib) {
            count += 1;
            if count == n {
                return next_fib;
            }
        }
    }
}

fn is_prime(num: i32) -> bool {
    if num <= 1 {
        return false;
    }
    if num <= 3 {
        return true;
    }
    if num % 2 == 0 || num % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_prime_fib() {
        assert_eq!(prime_fib(1), 2);
        assert_eq!(prime_fib(2), 3);
        assert_eq!(prime_fib(3), 5);
        assert_eq!(prime_fib(4), 13);
        assert_eq!(prime_fib(5), 89);
        assert_eq!(prime_fib(6), 233);
        assert_eq!(prime_fib(7), 1597);
        assert_eq!(prime_fib(8), 28657);
        assert_eq!(prime_fib(9), 514229);
        assert_eq!(prime_fib(10), 433494437);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/40 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triples_sum_to_zero(nmbs:Vec<i32>) -> bool{

let mut nmbs = nmbs;
    nmbs.sort(); // Sort the numbers first

    for i in 0..nmbs.len() {
        if i > 0 && nmbs[i] == nmbs[i - 1] {
            continue; // Skip duplicate elements to avoid duplicate triplets
        }

        let (mut left, mut right) = (i + 1, nmbs.len() - 1);
        while left < right {
            let sum = nmbs[i] + nmbs[left] + nmbs[right];
            if sum == 0 {
                return true; // Found a triplet that sums to zero
            } else if sum < 0 {
                left += 1; // Increase the sum by moving the left pointer to the right
            } else {
                right -= 1; // Decrease the sum by moving the right pointer to the left
            }
        }
    }

    false // No triplet found that sums to zero
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_triples_sum_to_zero() {
        assert!(triples_sum_to_zero(vec![1, 3, 5, 0]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, 5, -1]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, -2, 1]) == true);
        assert!(triples_sum_to_zero(vec![1, 2, 3, 7]) == false);
        assert!(triples_sum_to_zero(vec![1, 2, 5, 7]) == false);
        assert!(triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7]) == true);
        assert!(triples_sum_to_zero(vec![1]) == false);
        assert!(triples_sum_to_zero(vec![1, 3, 5, -100]) == false);
        assert!(triples_sum_to_zero(vec![100, 3, 5, -100]) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/41 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn car_race_collision(n:i32)-> i32{

// Each car moving left to right will collide with each car moving right to left
    n * n
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_car_race_collision() {
        assert!(car_race_collision(2) == 4);
        assert!(car_race_collision(3) == 9);
        assert!(car_race_collision(4) == 16);
        assert!(car_race_collision(8) == 64);
        assert!(car_race_collision(10) == 100);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/42 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn incr_list(l:Vec<i32>) -> Vec<i32>{

l.into_iter().map(|x| x + 1).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_incr_list() {
        assert!(incr_list(vec![]) == vec![]);
        assert!(incr_list(vec![3, 2, 1]) == [4, 3, 2]);
        assert!(incr_list(vec![5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/43 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn pairs_sum_to_zero(l:Vec<i32>) -> bool{

let mut seen = HashSet::new();
    for &num in &l {
        if seen.contains(&-num) {
            return true;
        }
        seen.insert(num);
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pairs_sum_to_zero() {
        assert!(pairs_sum_to_zero(vec![1, 3, 5, 0]) == false);
        assert!(pairs_sum_to_zero(vec![1, 3, -2, 1]) == false);
        assert!(pairs_sum_to_zero(vec![1, 2, 3, 7]) == false);
        assert!(pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7]) == true);
        assert!(pairs_sum_to_zero(vec![1]) == false);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 30]) == true);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 3, 2, 31]) == true);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 30]) == false);
        assert!(pairs_sum_to_zero(vec![-3, 9, -1, 4, 2, 31]) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/44 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn change_base(x:i32, base:i32) -> String{

if base < 2 || base > 9 {
        panic!("Base must be between 2 and 9");
    }

    if x == 0 {
        return "0".to_string();
    }

    let mut num = x.abs();
    let mut result = String::new();

    while num > 0 {
        let remainder = num % base;
        result.push((b'0' + remainder as u8) as char);
        num /= base;
    }

    if x < 0 {
        result.push('-');
    }

    result.chars().rev().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_change_base() {
        assert!(change_base(8, 3) == "22".to_string());
        assert!(change_base(9, 3) == "100".to_string());
        assert!(change_base(234, 2) == "11101010".to_string());
        assert!(change_base(16, 2) == "10000".to_string());
        assert!(change_base(8, 2) == "1000".to_string());
        assert!(change_base(7, 2) == "111".to_string());
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/45 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triangle_area(a:i32, h:i32) -> f64{

// Check if the sides form a valid triangle
    if a + b <= c || a + c <= b || b + c <= a {
        return -1.0;
    }

    // Calculate the semi-perimeter
    let s = (a + b + c) as f64 / 2.0;

    // Calculate the area using Heron's formula
    let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();

    // Return the area rounded to 2 decimal points
    (area * 100.0).round() / 100.0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_triangle_area() {
        assert!(triangle_area(5, 3) == 7.5);
        assert!(triangle_area(2, 2) == 2.0);
        assert!(triangle_area(10, 8) == 40.0);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_45_gen0.jsonl

Testing Rust/46 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fib4(n:i32) -> i32{

if n < 0 {
        panic!("n must be a non-negative integer");
    }

    // Base cases
    match n {
        0 => return 0,
        1 => return 0,
        2 => return 2,
        3 => return 0,
        _ => {}
    }

    // Array to store the last four computed values
    let mut fib4_values = [0, 0, 2, 0];
    let mut current = 0;

    // Compute the fib4 sequence iteratively
    for i in 4..=n {
        current = fib4_values[0] + fib4_values[1] + fib4_values[2] + fib4_values[3];
        // Shift the values to the left
        fib4_values[0] = fib4_values[1];
        fib4_values[1] = fib4_values[2];
        fib4_values[2] = fib4_values[3];
        fib4_values[3] = current;
    }

    current
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib4() {
        assert!(fib4(5) == 4);
        assert!(fib4(8) == 28);
        assert!(fib4(10) == 104);
        assert!(fib4(12) == 386);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/47 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn median(l:Vec<i32>) -> f64{

if l.is_empty() {
        panic!("The list is empty");
    }

    l.sort();

    let len = l.len();
    if len % 2 == 0 {
        // Even number of elements
        let mid1 = l[len / 2 - 1];
        let mid2 = l[len / 2];
        (mid1 as f64 + mid2 as f64) / 2.0
    } else {
        // Odd number of elements
        l[len / 2] as f64
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_median() {
        assert!(median(vec![3, 1, 2, 4, 5]) == 3.0);
        assert!(median(vec![-10, 4, 6, 1000, 10, 20]) == 8.0);
        assert!(median(vec![5]) == 5.0);
        assert!(median(vec![6, 5]) == 5.5);
        assert!(median(vec![8, 1, 3, 9, 9, 2, 7]) == 7.0);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_47_gen0.jsonl

Testing Rust/48 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_palindrome(text: String) -> bool {

let cleaned_text: String = text.chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_ascii_lowercase())
        .collect();
    cleaned_text == cleaned_text.chars().rev().collect::<String>()
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("".to_string()) == true);
        assert!(is_palindrome("aba".to_string()) == true);
        assert!(is_palindrome("aaaaa".to_string()) == true);
        assert!(is_palindrome("zbcd".to_string()) == false);
        assert!(is_palindrome("xywyx".to_string()) == true);
        assert!(is_palindrome("xywyz".to_string()) == false);
        assert!(is_palindrome("xywzx".to_string()) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/49 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn modp(n: i32, p: i32) -> i32 {

if p == 1 {
        return 0;
    }
    let mut result = 1;
    let mut base = 2;
    let mut exponent = n;

    while exponent > 0 {
        if exponent % 2 == 1 {
            result = (result * base) % p;
        }
        base = (base * base) % p;
        exponent /= 2;
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modp() {
        assert!(modp(3, 5) == 3);
        assert!(modp(1101, 101) == 2);
        assert!(modp(0, 101) == 1);
        assert!(modp(3, 11) == 8);
        assert!(modp(100, 101) == 1);
        assert!(modp(30, 5) == 4);
        assert!(modp(31, 5) == 3);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/50 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encode_shift(s: &str) -> String {

    let alphabet:Vec<&str> = vec!["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"
    , "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
    let mut output = String::new();

    for c in s.chars() {
        let mut lower = false;
        if c.is_ascii_lowercase(){
            lower = true;
        }
        let mut c_shift:String = "".to_string();
        if lower {
            let index:usize = alphabet.iter().position(|&x| x == c.to_string()).unwrap();
            c_shift = alphabet[(index + 5) % 26].to_string();
        }else{
            let c_lower:String = c.to_ascii_lowercase().to_string();
            let index:usize = alphabet.iter().position(|&x| x == c_lower).unwrap();
            c_shift = alphabet[(index + 5) % 26].to_string();
            c_shift = c_shift.to_ascii_uppercase().to_string();
            
        }

        output.push_str(&c_shift);
    }
    output
}

pub fn decode_shift(s: &str) -> String {
let alphabet: Vec<&str> = vec!["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"
    , "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
    let mut output = String::new();

    for c in s.chars() {
        let mut lower = false;
        if c.is_ascii_lowercase() {
            lower = true;
        }
        let mut c_shift: String = "".to_string();
        if lower {
            let index: usize = alphabet.iter().position(|&x| x == c.to_string()).unwrap();
            c_shift = alphabet[(index + 21) % 26].to_string(); // 21 = 26 - 5
        } else {
            let c_lower: String = c.to_ascii_lowercase().to_string();
            let index: usize = alphabet.iter().position(|&x| x == c_lower).unwrap();
            c_shift = alphabet[(index + 21) % 26].to_string(); // 21 = 26 - 5
            c_shift = c_shift.to_ascii_uppercase().to_string();
        }

        output.push_str(&c_shift);
    }
    output
}

fn encode_shift(s: &str) -> String {
    let alphabet: Vec<&str> = vec!["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"
    , "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
    let mut output = String::new();

    for c in s.chars() {
        let mut lower = false;
        if c.is_ascii_lowercase() {
            lower = true;
        }
        let mut c_shift: String = "".to_string();
        if lower {
            let index: usize = alphabet.iter().position(|&x| x == c.to_string()).unwrap();
            c_shift = alphabet[(index + 5) % 26].to_string();
        } else {
            let c_lower: String = c.to_ascii_lowercase().to_string();
            let index: usize = alphabet.iter().position(|&x| x == c_lower).unwrap();
            c_shift = alphabet[(index + 5) % 26].to_string();
            c_shift = c_shift.to_ascii_uppercase().to_string();
        }

        output.push_str(&c_shift);
    }
    output
}

pub 



#[cfg(test)]
mod tests {
    use super::*;

#[test]
    //Imposing that random characters that can be generated are solely from the alphabet
    fn test_decode_encode() {
        fn random_char() -> char {
            let mut rng = rand::thread_rng();
            let letter: char = match rng.gen_range(0, 2) {
                0 => rng.gen_range(b'a', b'z' + 1).into(),
                1 => rng.gen_range(b'A', b'Z' + 1).into(),
                _ => unreachable!(),
            };
            return letter;
        }

        let mut rng = rand::thread_rng();
        for _ in 0..100 {
            let r1: i32 = rng.gen();
            let l: i32 = 10 + r1 % 11;
            let mut str: String = "".to_string();

            for _ in 0..l {
                let chr: char = random_char();
                println!("{}", chr);
                str.push(chr);
            }

            let encoded_str: String = encode_shift(&str);
            assert!(decode_shift(&encoded_str) == str);
        }
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_50_gen0.jsonl

Testing Rust/51 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn remove_vowels(text: &str) -> String {

let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
    text.chars()
        .filter(|c| !vowels.contains(c))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_remove_vowels() {
        assert!(remove_vowels("") == "");
        assert!(remove_vowels("abcdef\nghijklm") == "bcdf\nghjklm");
        assert!(remove_vowels("fedcba") == "fdcb");
        assert!(remove_vowels("eeeee") == "");
        assert!(remove_vowels("acBAA") == "cB");
        assert!(remove_vowels("EcBOO") == "cB");
        assert!(remove_vowels("ybcd") == "ybcd");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/52 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn below_threshold(l: Vec<i32>, t: i32) -> bool { 

for &num in l.iter() {
        if num >= t {
            return false;
        }
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_below_threshold() {
        assert!(below_threshold(vec![1, 2, 4, 10], 100));
        assert!(!below_threshold(vec![1, 20, 4, 10], 5));
        assert!(below_threshold(vec![1, 20, 4, 10], 21));
        assert!(below_threshold(vec![1, 20, 4, 10], 22));
        assert!(below_threshold(vec![1, 8, 4, 10], 11));
        assert!(!below_threshold(vec![1, 8, 4, 10], 10));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/53 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add(x:i32, y:i32) -> i32{

x + y
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert!(add(0, 1) == 1);
        assert!(add(1, 0) == 1);
        assert!(add(2, 3) == 5);
        assert!(add(5, 7) == 12);
        assert!(add(7, 5) == 12);
        for _ in 0..100 {
            let mut rng = rand::thread_rng();
            let mut x: i32 = rng.gen();
            x = x % 1000;
            let mut y: i32 = rng.gen();
            y = y % 1000;

            assert!(add(x, y) == x + y);
        }
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/54 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn same_chars(str1:&str, str2:&str) -> bool{

// Convert both strings to character sets
    let set1: HashSet<char> = str1.chars().collect();
    let set2: HashSet<char> = str2.chars().collect();
    
    // Compare the two sets
    set1 == set2
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_same_chars() {
        assert!(same_chars("eabcdzzzz", "dddzzzzzzzddeddabc") == true);
        assert!(same_chars("abcd", "dddddddabc") == true);
        assert!(same_chars("dddddddabc", "abcd") == true);
        assert!(same_chars("eabcd", "dddddddabc") == false);
        assert!(same_chars("abcd", "dddddddabcf") == false);
        assert!(same_chars("eabcdzzzz", "dddzzzzzzzddddabc") == false);
        assert!(same_chars("aabb", "aaccc") == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/55 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fib(n:i32) -> i32{

if n <= 0 {
        return 0;
    } else if n == 1 {
        return 1;
    }

    let mut a = 0;
    let mut b = 1;
    let mut fib_n = 0;

    for _ in 2..=n {
        fib_n = a + b;
        a = b;
        b = fib_n;
    }

    fib_n
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib() {
        assert!(fib(10) == 55);
        assert!(fib(1) == 1);
        assert!(fib(8) == 21);
        assert!(fib(11) == 89);
        assert!(fib(12) == 144);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/56 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn correct_bracketing(bkts:&str) -> bool{

let mut open_count = 0;

    for ch in bkts.chars() {
        match ch {
            '<' => open_count += 1,
            '>' => {
                if open_count == 0 {
                    return false;
                }
                open_count -= 1;
            }
            _ => {} // Ignore any other characters, though the problem specifies only '<' and '>'
        }
    }

    open_count == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_correct_bracketing() {
        assert!(correct_bracketing("<>"));
        assert!(correct_bracketing("<<><>>"));
        assert!(correct_bracketing("<><><<><>><>"));
        assert!(correct_bracketing("<><><<<><><>><>><<><><<>>>"));
        assert!(!(correct_bracketing("<<<><>>>>")));
        assert!(!(correct_bracketing("><<>")));
        assert!(!(correct_bracketing("<")));
        assert!(!(correct_bracketing("<<<<")));
        assert!(!(correct_bracketing(">")));
        assert!(!(correct_bracketing("<<>")));
        assert!(!(correct_bracketing("<><><<><>><>><<>")));
        assert!(!(correct_bracketing("<><><<><>><>>><>")));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/57 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn monotonic( l:Vec<i32>) -> bool{

if l.is_empty() {
        return true;
    }

    let mut increasing = true;
    let mut decreasing = true;

    for i in 1..l.len() {
        if l[i] > l[i - 1] {
            decreasing = false;
        }
        if l[i] < l[i - 1] {
            increasing = false;
        }
    }

    increasing || decreasing
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_monotonic() {
        assert!(monotonic(vec![1, 2, 4, 10]) == true);
        assert!(monotonic(vec![1, 2, 4, 20]) == true);
        assert!(monotonic(vec![1, 20, 4, 10]) == false);
        assert!(monotonic(vec![4, 1, 0, -10]) == true);
        assert!(monotonic(vec![4, 1, 1, 0]) == true);
        assert!(monotonic(vec![1, 2, 3, 2, 5, 60]) == false);
        assert!(monotonic(vec![1, 2, 3, 4, 5, 60]) == true);
        assert!(monotonic(vec![9, 9, 9, 9]) == true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/58 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn common(l1:Vec<i32>, l2:Vec<i32>) -> Vec<i32>{

// Convert the first list to a HashSet to remove duplicates and allow for fast lookup
    let set1: HashSet<i32> = l1.into_iter().collect();
    
    // Use a HashSet to store the common elements
    let mut common_elements = HashSet::new();
    
    // Iterate over the second list and check if each element is in the first set
    for &item in &l2 {
        if set1.contains(&item) {
            common_elements.insert(item);
        }
    }
    
    // Convert the HashSet to a Vec and sort it
    let mut result: Vec<i32> = common_elements.into_iter().collect();
    result.sort();
    
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_common() {
        assert!(
            common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]) == vec![1, 5, 653]
        );
        assert!(common(vec![5, 3, 2, 8], vec![3, 2]) == vec![2, 3]);
        assert!(common(vec![4, 3, 2, 8], vec![3, 2, 4]) == vec![2, 3, 4]);
        assert!(common(vec![4, 3, 2, 8], vec![]) == vec![]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/59 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_prime_factor(n:i32) -> i32{

let mut n = n;
    let mut largest_factor = 1;
    let mut factor = 2;

    while n % factor == 0 {
        largest_factor = factor;
        n /= factor;
    }

    factor = 3;
    while n > 1 {
        while n % factor == 0 {
            largest_factor = factor;
            n /= factor;
        }
        factor += 2;
    }

    largest_factor
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_largest_prime_factor() {
        assert!(largest_prime_factor(15) == 5);
        assert!(largest_prime_factor(27) == 3);
        assert!(largest_prime_factor(63) == 7);
        assert!(largest_prime_factor(330) == 11);
        assert!(largest_prime_factor(13195) == 29);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/60 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_to_n(n: i32) -> i32 {

if n < 1 {
        return 0;
    }
    (1..=n).sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_to_n() {
        assert!(sum_to_n(1) == 1);
        assert!(sum_to_n(6) == 21);
        assert!(sum_to_n(11) == 66);
        assert!(sum_to_n(30) == 465);
        assert!(sum_to_n(100) == 5050);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/61 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn correct_bracketing_parenthesis(bkts:&str) -> bool{

fn correct_bracketing_parenthesis(bkts: &str) -> bool {
    let mut balance = 0;

    for c in bkts.chars() {
        match c {
            '(' => balance += 1,
            ')' => {
                if balance == 0 {
                    return false;
                }
                balance -= 1;
            }
            _ => {} // Ignore any other characters, though the problem specifies only '(' and ')'
        }
    }

    balance == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_correct_bracketing_parenthesis() {
        assert!(correct_bracketing_parenthesis("()"));
        assert!(correct_bracketing_parenthesis("(()())"));
        assert!(correct_bracketing_parenthesis("()()(()())()"));
        assert!(correct_bracketing_parenthesis("()()((()()())())(()()(()))"));
        assert!(!(correct_bracketing_parenthesis("((()())))")));
        assert!(!(correct_bracketing_parenthesis(")(()")));
        assert!(!(correct_bracketing_parenthesis("(")));
        assert!(!(correct_bracketing_parenthesis("((((")));
        assert!(!(correct_bracketing_parenthesis(")")));
        assert!(!(correct_bracketing_parenthesis("(()")));
        assert!(!(correct_bracketing_parenthesis("()()(()())())(()")));
        assert!(!(correct_bracketing_parenthesis("()()(()())()))()")));
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_61_gen0.jsonl

Testing Rust/62 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn derivative(xs:Vec<i32>) -> Vec<i32>{

// If the polynomial is constant or empty, its derivative is an empty vector
    if xs.len() <= 1 {
        return Vec::new();
    }

    // Create a new vector to store the derivative coefficients
    let mut deriv_coeffs = Vec::with_capacity(xs.len() - 1);

    // Iterate over the coefficients starting from the first power of x (index 1)
    for (i, &coeff) in xs.iter().enumerate().skip(1) {
        deriv_coeffs.push(i as i32 * coeff);
    }

    deriv_coeffs
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_derivative() {
        assert!(derivative(vec![3, 1, 2, 4, 5]) == vec![1, 4, 12, 20]);
        assert!(derivative(vec![1, 2, 3]) == vec![2, 6]);
        assert!(derivative(vec![3, 2, 1]) == vec![2, 2]);
        assert!(derivative(vec![3, 2, 1, 0, 4]) == vec![2, 2, 0, 16]);
        assert!(derivative(vec![1]) == vec![]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/63 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fibfib(n:i32) -> i32{

if n == 0 {
        return 0;
    } else if n == 1 {
        return 0;
    } else if n == 2 {
        return 1;
    }

    let mut fibfib_values = vec![0, 0, 1];

    for i in 3..=n {
        let next_value = fibfib_values[(i - 1) as usize] + fibfib_values[(i - 2) as usize] + fibfib_values[(i - 3) as usize];
        fibfib_values.push(next_value);
    }

    fibfib_values[n as usize]
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_fibfib() {
        assert!(fibfib(2) == 1);
        assert!(fibfib(1) == 0);
        assert!(fibfib(5) == 4);
        assert!(fibfib(8) == 24);
        assert!(fibfib(10) == 81);
        assert!(fibfib(12) == 274);
        assert!(fibfib(14) == 927);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/64 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn vowels_count(s:&str) -> i32 {

// Define the set of vowels
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let mut count = 0;

    // Convert the string to lowercase to handle case insensitivity
    let chars: Vec<char> = s.chars().map(|c| c.to_ascii_lowercase()).collect();

    // Iterate over the characters in the string
    for (i, c) in chars.iter().enumerate() {
        // Check if the character is a vowel
        if vowels.contains(c) {
            count += 1;
        }
        // Check if 'y' is at the end of the word
        if *c == 'y' && i == chars.len() - 1 {
            count += 1;
        }
    }

    count
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_vowels_count() {
        assert!(vowels_count("abcde") == 2);
        assert!(vowels_count("Alone") == 3);
        assert!(vowels_count("key") == 2);
        assert!(vowels_count("bye") == 1);
        assert!(vowels_count("keY") == 2);
        assert!(vowels_count("bYe") == 1);
        assert!(vowels_count("ACEDY") == 3);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/65 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn circular_shift(x:i32, shift:i32) -> String{

// Convert the integer to a string to work with its digits
    let mut digits: Vec<char> = x.to_string().chars().collect();
    let num_digits = digits.len() as i32;

    // If shift is greater than the number of digits, return the reversed digits
    if shift >= num_digits {
        return digits.iter().rev().collect();
    }

    // Calculate the effective shift
    let effective_shift = shift % num_digits;

    // Perform the circular shift
    let split_point = (num_digits - effective_shift) as usize;
    let (left, right) = digits.split_at(split_point);
    let shifted: Vec<char> = right.iter().chain(left.iter()).cloned().collect();

    // Convert the shifted digits back to a string
    shifted.into_iter().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

 #[test]
    fn test_circular_shift() {
        assert!(circular_shift(100, 2) == "001");
        assert!(circular_shift(12, 8) == "12");
        // original test   asert (circular_shift(97, 8) == "79"); DATASET ERROR
        assert!(circular_shift(97, 8) == "97");
        assert!(circular_shift(12, 1) == "21");
        assert!(circular_shift(11, 101) == "11");
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_65_gen0.jsonl

Testing Rust/66 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn digitSum(s:&str) -> i32{

s.chars()
        .filter(|c| c.is_ascii_uppercase())
        .map(|c| c as i32)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_digitSum() {
        assert!(digitSum("") == 0);
        assert!(digitSum("abAB") == 131);
        assert!(digitSum("abcCd") == 67);
        assert!(digitSum("helloE") == 69);
        assert!(digitSum("woArBld") == 131);
        assert!(digitSum("aAaaaXa") == 153);
        assert!(digitSum(" How are yOu?") == 151);
        assert!(digitSum("You arE Very Smart") == 327);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/67 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fruit_distribution(s:&str, n:i32) -> i32 {

// Split the string into words
    let words: Vec<&str> = s.split_whitespace().collect();
    
    // Initialize counters for apples and oranges
    let mut apples = 0;
    let mut oranges = 0;
    
    // Iterate over the words to find the numbers of apples and oranges
    let mut i = 0;
    while i < words.len() {
        match words[i] {
            "apples" => {
                if i + 1 < words.len() {
                    apples = words[i + 1].parse().unwrap_or(0);
                }
            },
            "oranges" => {
                if i + 1 < words.len() {
                    oranges = words[i + 1].parse().unwrap_or(0);
                }
            },
            _ => {}
        }
        i += 1;
    }
    
    // Calculate the number of mangoes
    n - apples - oranges
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fruit_distribution() {
        assert!(fruit_distribution("5 apples and 6 oranges", 19) == 8);
        assert!(fruit_distribution("5 apples and 6 oranges", 21) == 10);
        assert!(fruit_distribution("0 apples and 1 oranges", 3) == 2);
        assert!(fruit_distribution("1 apples and 0 oranges", 3) == 2);
        assert!(fruit_distribution("2 apples and 3 oranges", 100) == 95);
        assert!(fruit_distribution("2 apples and 3 oranges", 5) == 0);
        assert!(fruit_distribution("1 apples and 100 oranges", 120) == 19);
    }


}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_67_gen0.jsonl

Testing Rust/68 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn pluck(arr:Vec<i32>) -> Vec<i32> {

let mut smallest_even: Option<(i32, usize)> = None;

    for (index, &value) in arr.iter().enumerate() {
        if value % 2 == 0 {
            match smallest_even {
                Some((smallest_value, _)) if value < smallest_value => {
                    smallest_even = Some((value, index));
                }
                None => {
                    smallest_even = Some((value, index));
                }
                _ => {}
            }
        }
    }

    match smallest_even {
        Some((value, index)) => vec![value, index as i32],
        None => vec![],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pluck() {
        assert!(pluck(vec![4, 2, 3]) == vec![2, 1]);
        assert!(pluck(vec![1, 2, 3]) == vec![2, 1]);
        assert!(pluck(vec![]) == vec![]);
        assert!(pluck(vec![5, 0, 3, 0, 4, 2]) == vec![0, 1]);
        assert!(pluck(vec![1, 2, 3, 0, 5, 3]) == vec![0, 3]);
        assert!(pluck(vec![5, 4, 8, 4, 8]) == vec![4, 1]);
        assert!(pluck(vec![7, 6, 7, 1]) == vec![6, 1]);
        assert!(pluck(vec![7, 9, 7, 1]) == vec![]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/69 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn search(lst: Vec<i32>) -> i32 {

let mut frequency_map = HashMap::new();

    // Count the frequency of each integer in the list
    for &num in &lst {
        *frequency_map.entry(num).or_insert(0) += 1;
    }

    let mut result = -1;

    // Iterate through the frequency map to find the greatest integer
    // that has a frequency greater than or equal to the integer itself
    for (&num, &count) in &frequency_map {
        if count >= num {
            result = cmp::max(result, num);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_search() {
        assert!(search(vec![5, 5, 5, 5, 1]) == 1);
        assert!(search(vec![4, 1, 4, 1, 4, 4]) == 4);
        assert!(search(vec![3, 3]) == -1);
        assert!(search(vec![8, 8, 8, 8, 8, 8, 8, 8]) == 8);
        assert!(search(vec![2, 3, 3, 2, 2]) == 2);
        assert!(
            search(vec![
                2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1
            ]) == 1
        );
        assert!(search(vec![3, 2, 8, 2]) == 2);
        assert!(search(vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1);
        assert!(search(vec![8, 8, 3, 6, 5, 6, 4]) == -1);
        assert!(
            search(vec![
                6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9
            ]) == 1
        );
        assert!(search(vec![1, 9, 10, 1, 3]) == 1);
        assert!(
            search(vec![
                6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10
            ]) == 5
        );
        assert!(search(vec![1]) == 1);
        assert!(
            search(vec![
                8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5
            ]) == 4
        );
        assert!(
            search(vec![
                2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10
            ]) == 2
        );
        assert!(search(vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1);
        assert!(
            search(vec![
                9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,
                10, 9, 4
            ]) == 4
        );
        assert!(
            search(vec![
                2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7
            ]) == 4
        );
        assert!(
            search(vec![
                9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1
            ]) == 2
        );
        assert!(
            search(vec![
                5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8
            ]) == -1
        );
        assert!(search(vec![10]) == -1);
        assert!(search(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2);
        assert!(search(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1);
        assert!(
            search(vec![
                7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6
            ]) == 1
        );
        assert!(search(vec![3, 10, 10, 9, 2]) == -1);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/70 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strange_sort_list(lst: Vec<i32>) -> Vec<i32>{

let mut result = Vec::new();
    let mut is_min_turn = true;

    while !lst.is_empty() {
        if is_min_turn {
            // Find the minimum value and its index
            let min_index = lst.iter().enumerate().min_by_key(|&(_, &val)| val).unwrap().0;
            result.push(lst.remove(min_index));
        } else {
            // Find the maximum value and its index
            let max_index = lst.iter().enumerate().max_by_key(|&(_, &val)| val).unwrap().0;
            result.push(lst.remove(max_index));
        }
        is_min_turn = !is_min_turn;
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

#[test]
    fn test_strange_sort_list() {
        assert!(strange_sort_list(vec![1, 2, 3, 4]) == vec![1, 4, 2, 3]);
        assert!(strange_sort_list(vec![5, 6, 7, 8, 9]) == vec![5, 9, 6, 8, 7]);
        assert!(strange_sort_list(vec![1, 2, 3, 4, 5]) == vec![1, 5, 2, 4, 3]);
        assert!(strange_sort_list(vec![5, 6, 7, 8, 9, 1]) == vec![1, 9, 5, 8, 6, 7]);
        assert!(strange_sort_list(vec![5, 5, 5, 5]) == vec![5, 5, 5, 5]);
        assert!(strange_sort_list(vec![]) == vec![]);
        assert!(strange_sort_list(vec![1, 2, 3, 4, 5, 6, 7, 8]) == vec![1, 8, 2, 7, 3, 6, 4, 5]);
        assert!(
            strange_sort_list(vec![0, 2, 2, 2, 5, 5, -5, -5]) == vec![-5, 5, -5, 5, 0, 2, 2, 2]
        );
        assert!(strange_sort_list(vec![111111]) == vec![111111]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_70_gen0.jsonl

Testing Rust/71 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{

fn triangle_area_f64(a: f64, b: f64, c: f64) -> f64 {
    // Check if the sides form a valid triangle
    if a + b <= c || a + c <= b || b + c <= a {
        return -1.0;
    }

    // Calculate the semi-perimeter
    let s = (a + b + c) / 2.0;

    // Calculate the area using Heron's formula
    let area = (s * (s - a) * (s - b) * (s - c)).sqrt();

    // Round the area to 2 decimal points
    (area * 100.0).round() / 100.0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_triangle_area_f64() {
        assert!(f64::abs(triangle_area_f64(3.0, 4.0, 5.0) - 6.00) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 10.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(4.0, 8.0, 5.0) - 8.18) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 2.0) - 1.73) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 2.0, 3.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(10.0, 5.0, 7.0) - 16.25) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 6.0, 3.0) + 1.0) < 0.01);
        assert!(f64::abs(triangle_area_f64(1.0, 1.0, 1.0) - 0.43) < 0.01);
        assert!(f64::abs(triangle_area_f64(2.0, 2.0, 10.0) + 1.0) < 0.01);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_71_gen0.jsonl

Testing Rust/72 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn will_it_fly(q:Vec<i32>, w:i32) -> bool{

// Check if the list is a palindrome
    let is_palindrome = q == q.iter().rev().cloned().collect::<Vec<i32>>();
    
    // Calculate the sum of the elements
    let sum_of_elements: i32 = q.iter().sum();
    
    // Check if the sum of elements is less than or equal to the maximum weight
    let within_weight_limit = sum_of_elements <= w;
    
    // The object will fly if it is a palindrome and within the weight limit
    is_palindrome && within_weight_limit
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_will_it_fly() {
        assert!(will_it_fly(vec![3, 2, 3], 9) == true);
        assert!(will_it_fly(vec![1, 2], 5) == false);
        assert!(will_it_fly(vec![3], 5) == true);
        assert!(will_it_fly(vec![3, 2, 3], 1) == false);
        assert!(will_it_fly(vec![1, 2, 3], 6) == false);
        assert!(will_it_fly(vec![5], 5) == true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/73 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn smallest_change(arr:Vec<i32>) -> i32{

let mut changes = 0;
    let n = arr.len();
    
    for i in 0..n / 2 {
        if arr[i] != arr[n - i - 1] {
            changes += 1;
        }
    }
    
    changes
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_smallest_change() {
        assert!(smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6]) == 4);
        assert!(smallest_change(vec![1, 2, 3, 4, 3, 2, 2]) == 1);
        assert!(smallest_change(vec![1, 4, 2]) == 1);
        assert!(smallest_change(vec![1, 4, 4, 2]) == 1);
        assert!(smallest_change(vec![1, 2, 3, 2, 1]) == 0);
        assert!(smallest_change(vec![3, 1, 1, 3]) == 0);
        assert!(smallest_change(vec![1]) == 0);
        assert!(smallest_change(vec![0, 1]) == 1);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/74 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn total_match(lst1:Vec<&str>, lst2:Vec<&str>) -> Vec<String>{

// Calculate the total number of characters in lst1
    let total_chars_lst1: usize = lst1.iter().map(|s| s.len()).sum();
    
    // Calculate the total number of characters in lst2
    let total_chars_lst2: usize = lst2.iter().map(|s| s.len()).sum();
    
    // Compare the total number of characters and return the appropriate list
    if total_chars_lst1 < total_chars_lst2 {
        lst1.into_iter().map(|s| s.to_string()).collect()
    } else {
        lst2.into_iter().map(|s| s.to_string()).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_total_match() {
        let v_empty: Vec<String> = vec![];
        assert!(total_match(vec![], vec![]) == v_empty);
        assert!(total_match(vec!["hi", "admin"], vec!["hi", "hi"]) == vec!["hi", "hi"]);
        assert!(
            total_match(vec!["hi", "admin"], vec!["hi", "hi", "admin", "project"])
                == vec!["hi", "admin"]
        );
        assert!(total_match(vec!["4"], vec!["1", "2", "3", "4", "5"]) == vec!["4"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "Hi"]) == vec!["hI", "Hi"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "hi", "hi"]) == vec!["hI", "hi", "hi"]);
        assert!(total_match(vec!["hi", "admin"], vec!["hI", "hi", "hii"]) == vec!["hi", "admin"]);
        assert!(total_match(vec![], vec!["this"]) == v_empty);
        assert!(total_match(vec!["this"], vec![]) == v_empty);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_74_gen0.jsonl

Testing Rust/75 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_multiply_prime(a: i32) -> bool {

// List of prime numbers less than 100
    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];

    // Check all combinations of three prime numbers
    for i in 0..primes.len() {
        for j in i..primes.len() {
            for k in j..primes.len() {
                if primes[i] * primes[j] * primes[k] == a {
                    return true;
                }
            }
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_multiply_prime() {
        assert!(is_multiply_prime(5) == false);
        assert!(is_multiply_prime(30) == true);
        assert!(is_multiply_prime(8) == true);
        assert!(is_multiply_prime(10) == false);
        assert!(is_multiply_prime(125) == true);
        assert!(is_multiply_prime(3 * 5 * 7) == true);
        assert!(is_multiply_prime(3 * 6 * 7) == false);
        assert!(is_multiply_prime(9 * 9 * 9) == false);
        assert!(is_multiply_prime(11 * 9 * 9) == false);
        assert!(is_multiply_prime(11 * 13 * 7) == true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/76 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_simple_power(x:i32, n:i32) -> bool{

if x == 1 {
        // 1 is a simple power of any number n (n^0 = 1)
        return true;
    }
    if n == 0 {
        // 0 raised to any positive power is 0, but 0^0 is undefined
        return false;
    }
    if n == 1 {
        // 1 raised to any power is 1, so only x = 1 is a simple power of 1
        return false;
    }
    if n == -1 {
        // -1 raised to an even power is 1, and to an odd power is -1
        return x == 1 || x == -1;
    }
    if n.abs() > x.abs() {
        // If the absolute value of n is greater than the absolute value of x,
        // n^k cannot equal x for any positive k
        return false;
    }

    let mut power = 1;
    let mut current = n;
    while current.abs() <= x.abs() {
        if current == x {
            return true;
        }
        if current > i32::MAX / n.abs() {
            // Prevent overflow
            break;
        }
        current *= n;
    }
    false
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_is_simple_power() {
        assert!(is_simple_power(1, 4) == true);
        assert!(is_simple_power(2, 2) == true);
        assert!(is_simple_power(8, 2) == true);
        assert!(is_simple_power(3, 2) == false);
        assert!(is_simple_power(3, 1) == false);
        assert!(is_simple_power(5, 3) == false);
        assert!(is_simple_power(16, 2) == true);
        assert!(is_simple_power(143214, 16) == false);
        assert!(is_simple_power(4, 2) == true);
        assert!(is_simple_power(9, 3) == true);
        assert!(is_simple_power(16, 4) == true);
        assert!(is_simple_power(24, 2) == false);
        assert!(is_simple_power(128, 4) == false);
        assert!(is_simple_power(12, 6) == false);
        assert!(is_simple_power(1, 1) == true);
        assert!(is_simple_power(1, 12) == true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/77 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn iscube(a:i32) -> bool{

if a == 0 {
        return true;
    }
    
    let mut abs_a = a.abs();
    let mut low: i32 = 0;
    let mut high: i32 = (abs_a as f64).cbrt() as i32 + 1;

    while low <= high {
        let mid = low + (high - low) / 2;
        let mid_cubed = mid as i64 * mid as i64 * mid as i64;

        if mid_cubed == abs_a as i64 {
            return true;
        } else if mid_cubed < abs_a as i64 {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_iscube() {
        assert!(iscube(1) == true);
        assert!(iscube(2) == false);
        assert!(iscube(-1) == true);
        assert!(iscube(64) == true);
        assert!(iscube(180) == false);
        assert!(iscube(1000) == true);
        assert!(iscube(0) == true);
        assert!(iscube(1729) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/78 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn hex_key(num:&str) -> i32{

// Define the set of prime hexadecimal digits
    let prime_hex_digits: HashSet<char> = ['2', '3', '5', '7', 'B', 'D'].iter().cloned().collect();
    
    // Count the number of prime hexadecimal digits in the input string
    num.chars().filter(|c| prime_hex_digits.contains(c)).count() as i32
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_hex_key() {
        assert!(hex_key("AB") == 1);
        assert!(hex_key("1077E") == 2);
        assert!(hex_key("ABED1A33") == 4);
        assert!(hex_key("2020") == 2);
        assert!(hex_key("123456789ABCDEF0") == 6);
        assert!(hex_key("112233445566778899AABBCCDDEEFF00") == 12);
        assert!(hex_key("") == 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/79 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn decimal_to_binary(decimal:i32) -> String{

// Convert the decimal number to binary
    let binary = format!("{:b}", decimal);
    // Format the binary string with 'db' at the beginning and end
    format!("db{}db", binary)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decimal_to_binary() {
        assert!(decimal_to_binary(0) == "db0db".to_string());
        assert!(decimal_to_binary(32) == "db100000db".to_string());
        assert!(decimal_to_binary(103) == "db1100111db".to_string());
        assert!(decimal_to_binary(15) == "db1111db".to_string());
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/80 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_happy(s:&str) -> bool{

if s.len() < 3 {
        return false;
    }

    s.as_bytes()
        .windows(3)
        .all(|window| window[0] != window[1] && window[1] != window[2] && window[0] != window[2])
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_happy() {
        assert!(is_happy("a") == false);
        assert!(is_happy("aa") == false);
        assert!(is_happy("abcd") == true);
        assert!(is_happy("aabb") == false);
        assert!(is_happy("adb") == true);
        assert!(is_happy("xyy") == false);
        assert!(is_happy("iopaxpoi") == true);
        assert!(is_happy("iopaxioi") == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/81 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn numerical_letter_grade(grades:Vec<f64>) -> Vec<String>{

grades.into_iter().map(|gpa| {
        if gpa == 4.0 {
            "A+".to_string()
        } else if gpa > 3.7 {
            "A".to_string()
        } else if gpa > 3.3 {
            "A-".to_string()
        } else if gpa > 3.0 {
            "B+".to_string()
        } else if gpa > 2.7 {
            "B".to_string()
        } else if gpa > 2.3 {
            "B-".to_string()
        } else if gpa > 2.0 {
            "C+".to_string()
        } else if gpa > 1.7 {
            "C".to_string()
        } else if gpa > 1.3 {
            "C-".to_string()
        } else if gpa > 1.0 {
            "D+".to_string()
        } else if gpa > 0.7 {
            "D".to_string()
        } else if gpa > 0.0 {
            "D-".to_string()
        } else {
            "E".to_string()
        }
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_numerical_letter_grade() {
        assert!(
            numerical_letter_grade(vec![4.0, 3.0, 1.7, 2.0, 3.5])
                == vec!["A+", "B", "C-", "C", "A-"]
        );
        assert!(numerical_letter_grade(vec![1.2]) == vec!["D+"]);
        assert!(numerical_letter_grade(vec![0.5]) == vec!["D-"]);
        assert!(numerical_letter_grade(vec![0.0]) == vec!["E"]);
        assert!(
            numerical_letter_grade(vec![1.0, 0.3, 1.5, 2.8, 3.3])
                == vec!["D", "D-", "C-", "B", "B+"]
        );
        assert!(numerical_letter_grade(vec![0.0, 0.7]) == vec!["E", "D-"]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/82 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prime_length(str:&str) -> bool{

let length = s.len();
    if length <= 1 {
        return false;
    }
    if length == 2 {
        return true;
    }
    if length % 2 == 0 {
        return false;
    }
    let sqrt_length = (length as f64).sqrt() as usize;
    for i in (3..=sqrt_length).step_by(2) {
        if length % i == 0 {
            return false;
        }
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prime_length() {
        assert!(prime_length("Hello") == true);
        assert!(prime_length("abcdcba") == true);
        assert!(prime_length("kittens") == true);
        assert!(prime_length("orange") == false);
        assert!(prime_length("wow") == true);
        assert!(prime_length("world") == true);
        assert!(prime_length("MadaM") == true);
        assert!(prime_length("Wow") == true);
        assert!(prime_length("") == false);
        assert!(prime_length("HI") == true);
        assert!(prime_length("go") == true);
        assert!(prime_length("gogo") == false);
        assert!(prime_length("aaaaaaaaaaaaaaa") == false);
        assert!(prime_length("Madam") == true);
        assert!(prime_length("M") == false);
        assert!(prime_length("0") == false);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_82_gen0.jsonl

Testing Rust/83 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn starts_one_ends(n:i32) -> i32{

if n <= 0 {
        return 0;
    }
    
    if n == 1 {
        // For 1-digit numbers, the numbers are 1, 2, ..., 9
        // Only 1 starts or ends with 1
        return 1;
    }
    
    let start_with_1 = 10_i32.pow((n - 1) as u32);
    let end_with_1 = 9 * 10_i32.pow((n - 1) as u32);
    let start_and_end_with_1 = 10_i32.pow((n - 2) as u32);
    
    start_with_1 + end_with_1 - start_and_end_with_1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_starts_one_ends() {
        assert!(starts_one_ends(1) == 1);
        assert!(starts_one_ends(2) == 18);
        assert!(starts_one_ends(3) == 180);
        assert!(starts_one_ends(4) == 1800);
        assert!(starts_one_ends(5) == 18000);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_83_gen0.jsonl

Testing Rust/84 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solve(n:i32) -> String{

// Step 1: Convert the integer to its decimal digits and sum them
    let digit_sum: i32 = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as i32).sum();
    
    // Step 2: Convert the sum to a binary string
    format!("{:b}", digit_sum)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solve() {
        assert!(solve(1000) == "1");
        assert!(solve(150) == "110");
        assert!(solve(147) == "1100");
        assert!(solve(333) == "1001");
        assert!(solve(963) == "10010");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/85 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add_even_odd(lst: Vec<i32>) -> i32{

fn add_even_odd(lst: Vec<i32>) -> i32 {
    lst.iter()
        .enumerate()
        .filter(|&(index, &value)| index % 2 != 0 && value % 2 == 0)
        .map(|(_, &value)| value)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_even_odd() {
        assert!(add_even_odd(vec![4, 88]) == 88);
        assert!(add_even_odd(vec![4, 5, 6, 7, 2, 122]) == 122);
        assert!(add_even_odd(vec![4, 0, 6, 7]) == 0);
        assert!(add_even_odd(vec![4, 4, 6, 8]) == 12);
    }


}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_85_gen0.jsonl

Testing Rust/86 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn anti_shuffle(s:&str) -> String{

// Split the input string into words
    let words: Vec<&str> = s.split_whitespace().collect();
    
    // Process each word
    let mut sorted_words = Vec::new();
    for word in words {
        // Convert the word to a mutable vector of characters
        let mut chars: Vec<char> = word.chars().collect();
        // Sort the characters
        chars.sort_unstable();
        // Collect the sorted characters back into a string
        let sorted_word: String = chars.into_iter().collect();
        // Add the sorted word to the result vector
        sorted_words.push(sorted_word);
    }
    
    // Join the sorted words with spaces to form the final result
    sorted_words.join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_anti_shuffle() {
        assert!(anti_shuffle("Hi") == "Hi".to_string());
        assert!(anti_shuffle("hello") == "ehllo".to_string());
        assert!(anti_shuffle("number") == "bemnru".to_string());
        assert!(anti_shuffle("abcd") == "abcd".to_string());
        assert!(anti_shuffle("Hello World!!!") == "Hello !!!Wdlor".to_string());
        assert!(anti_shuffle("") == "".to_string());
        assert!(
            anti_shuffle("Hi. My name is Mister Robot. How are you?")
                == ".Hi My aemn is Meirst .Rboot How aer ?ouy".to_string()
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/87 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_row(lst:Vec<Vec<i32>>, x:i32) -> Vec<Vec<i32>>{

let mut coordinates = Vec::new();

    // Collect coordinates of x in the list
    for (row_index, row) in lst.iter().enumerate() {
        for (col_index, &value) in row.iter().enumerate() {
            if value == x {
                coordinates.push((row_index, col_index));
            }
        }
    }

    // Sort coordinates by row in ascending order and by column in descending order
    coordinates.sort_by(|a, b| {
        if a.0 == b.0 {
            b.1.cmp(&a.1) // Sort by column in descending order if rows are the same
        } else {
            a.0.cmp(&b.0) // Sort by row in ascending order
        }
    });

    coordinates
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_row() {
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 1, 6],
                    vec![1, 2, 3, 4, 5, 1]
                ],
                1
            ) == vec![vec![0, 0], vec![1, 0], vec![1, 4], vec![2, 0], vec![2, 5]]
        );
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6]
                ],
                2
            ) == vec![
                vec![0, 1],
                vec![1, 1],
                vec![2, 1],
                vec![3, 1],
                vec![4, 1],
                vec![5, 1]
            ]
        );
        assert!(
            get_row(
                vec![
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 2, 3, 4, 5, 6],
                    vec![1, 1, 3, 4, 5, 6],
                    vec![1, 2, 1, 4, 5, 6],
                    vec![1, 2, 3, 1, 5, 6],
                    vec![1, 2, 3, 4, 1, 6],
                    vec![1, 2, 3, 4, 5, 1]
                ],
                1
            ) == vec![
                vec![0, 0],
                vec![1, 0],
                vec![2, 0],
                vec![2, 1],
                vec![3, 0],
                vec![3, 2],
                vec![4, 0],
                vec![4, 3],
                vec![5, 0],
                vec![5, 4],
                vec![6, 0],
                vec![6, 5]
            ]
        );
        let v: Vec<Vec<i32>> = vec![];
        assert!(get_row(vec![], 1) == v);
        assert!(get_row(vec![vec![1]], 2) == v);
        assert!(get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3) == vec![vec![2, 2]]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_87_gen0.jsonl

Testing Rust/88 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_array(array:Vec<i32>) -> Vec<i32>{

let mut array = array;
    array.sort_unstable_by_key(|&num| (num.count_ones(), num));
    array
}

#[cfg(test)]
mod tests {
    use super::*;

  #[test]
    fn test_sort_array() {
        assert!(sort_array(vec![]) == vec![]);
        assert!(sort_array(vec![5]) == vec![5]);
        assert!(sort_array(vec![2, 4, 3, 0, 1, 5]) == vec![0, 1, 2, 3, 4, 5]);
        assert!(sort_array(vec![2, 4, 3, 0, 1, 5, 6]) == vec![6, 5, 4, 3, 2, 1, 0]);
        assert!(sort_array(vec![2, 1]) == vec![1, 2]);
        assert!(sort_array(vec![15, 42, 87, 32, 11, 0]) == vec![0, 11, 15, 32, 42, 87]);
        assert!(sort_array(vec![21, 14, 23, 11]) == vec![23, 21, 14, 11]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_88_gen0.jsonl

Testing Rust/89 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encrypt(s:&str) -> String{

let shift = 4;
    s.chars()
        .map(|c| {
            if c.is_ascii_alphabetic() {
                let base = if c.is_ascii_lowercase() { 'a' } else { 'A' } as u8;
                let shifted = ((c as u8 - base + shift) % 26) + base;
                shifted as char
            } else {
                c
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encrypt() {
        assert!(encrypt("hi") == "lm");
        assert!(encrypt("asdfghjkl") == "ewhjklnop");
        assert!(encrypt("gf") == "kj");
        assert!(encrypt("et") == "ix");
        assert!(encrypt("faewfawefaewg") == "jeiajeaijeiak");
        assert!(encrypt("hellomyfriend") == "lippsqcjvmirh");
        assert!(
            encrypt("dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh")
                == "hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl"
        );
        assert!(encrypt("a") == "e");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/90 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn next_smallest(lst:Vec<i32>) -> i32{

if lst.len() < 2 {
        return None;
    }

    let mut smallest = i32::MAX;
    let mut second_smallest = i32::MAX;

    for &value in &lst {
        if value < smallest {
            second_smallest = smallest;
            smallest = value;
        } else if value < second_smallest && value != smallest {
            second_smallest = value;
        }
    }

    if second_smallest == i32::MAX {
        None
    } else {
        Some(second_smallest)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_next_smallest() {
        assert!(next_smallest(vec![1, 2, 3, 4, 5]) == 2);
        assert!(next_smallest(vec![5, 1, 4, 3, 2]) == 2);
        assert!(next_smallest(vec![]) == -1);
        assert!(next_smallest(vec![1, 1]) == -1);
        assert!(next_smallest(vec![1, 1, 1, 1, 0]) == 1);
        assert!(next_smallest(vec![-35, 34, 12, -45]) == -35);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_90_gen0.jsonl

Testing Rust/91 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_bored(s:&str) -> i32 {

// Split the string into sentences using regex to match '.', '?', or '!' followed by a space or end of string
    let re = Regex::new(r"[.?!]\s*").unwrap();
    let sentences: Vec<&str> = re.split(s).collect();

    // Count sentences that start with "I"
    let mut boredom_count = 0;
    for sentence in sentences {
        let trimmed_sentence = sentence.trim();
        if trimmed_sentence.starts_with("I ") || trimmed_sentence == "I" {
            boredom_count += 1;
        }
    }

    boredom_count
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_bored() {
        assert!(is_bored("Hello world") == 0);
        assert!(is_bored("Is the sky blue?") == 0);
        assert!(is_bored("I love It !") == 1);
        assert!(is_bored("bIt") == 0);
        assert!(is_bored("I feel good today. I will be productive. will kill It") == 2);
        assert!(is_bored("You and I are going for a walk") == 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/92 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn any_int(a:f64, b:f64, c:f64) -> bool{

// Check if all numbers are integers
    if a.fract() != 0.0 || b.fract() != 0.0 || c.fract() != 0.0 {
        return false;
    }

    // Convert to integers
    let a_int = a as i64;
    let b_int = b as i64;
    let c_int = c as i64;

    // Check if one of the numbers is the sum of the other two
    if a_int == b_int + c_int || b_int == a_int + c_int || c_int == a_int + b_int {
        return true;
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_any_int() {
        assert!(any_int(2.0, 3.0, 1.0) == true);
        assert!(any_int(2.5, 2.0, 3.0) == false);
        assert!(any_int(1.5, 5.0, 3.5) == false);
        assert!(any_int(2.0, 6.0, 2.0) == false);
        assert!(any_int(4.0, 2.0, 2.0) == true);
        assert!(any_int(2.2, 2.2, 2.2) == false);
        assert!(any_int(-4.0, 6.0, 2.0) == true);
        assert!(any_int(2.0, 1.0, 1.0) == true);
        assert!(any_int(3.0, 4.0, 7.0) == true);
        assert!(any_int(3.01, 4.0, 7.0) == false);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/93 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn encode(message:&str) -> String{

// Define a mapping for vowels to their corresponding characters 2 places ahead
    let vowel_map: HashMap<char, char> = [
        ('a', 'c'), ('e', 'g'), ('i', 'k'), ('o', 'q'), ('u', 'w'),
        ('A', 'C'), ('E', 'G'), ('I', 'K'), ('O', 'Q'), ('U', 'W')
    ].iter().cloned().collect();

    message.chars().map(|c| {
        if c.is_alphabetic() {
            // Swap case
            let swapped_case = if c.is_lowercase() {
                c.to_ascii_uppercase()
            } else {
                c.to_ascii_lowercase()
            };

            // Replace vowel if applicable
            *vowel_map.get(&swapped_case).unwrap_or(&swapped_case)
        } else {
            c // If not alphabetic, return the character as is (though the problem states only letters)
        }
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode() {
        assert!(encode("TEST") == "tgst");
        assert!(encode("Mudasir") == "mWDCSKR");
        assert!(encode("YES") == "ygs");
        assert!(encode("This is a message") == "tHKS KS C MGSSCGG");
        assert!(encode("I DoNt KnOw WhAt tO WrItE") == "k dQnT kNqW wHcT Tq wRkTg");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/94 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn skjkasdkd(lst:Vec<i32>) -> i32{

// Helper function to check if a number is prime

fn is_prime(n: i32) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 || n % 3 == 0 {
            return false;
        }
        let mut i = 5;
        while i * i <= n {
            if n % i == 0 || n % (i + 2) == 0 {
                return false;
            }
            i += 6;
        }
        true
    }

    // Find the largest prime number in the list
    let mut largest_prime = None;
    for &num in &lst {
        if is_prime(num) {
            largest_prime = Some(match largest_prime {
                Some(current_max) => max(current_max, num),
                None => num,
            });
        }
    }

    // Calculate the sum of the digits of the largest prime number
    match largest_prime {
        Some(prime) => prime.to_string().chars().map(|c| c.to_digit(10).unwrap() as i32).sum(),
        None => 0, // If no prime number is found, return 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skjkasdkd() {
        assert!(
            skjkasdkd(vec![
                0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3
            ]) == 10
        );
        assert!(
            skjkasdkd(vec![
                1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1
            ]) == 25
        );
        assert!(
            skjkasdkd(vec![
                1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3
            ]) == 13
        );
        assert!(skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11);
        assert!(skjkasdkd(vec![0, 81, 12, 3, 1, 21]) == 3);
        assert!(skjkasdkd(vec![0, 8, 1, 2, 1, 7]) == 7);
        assert!(skjkasdkd(vec![8191]) == 19);
        assert!(skjkasdkd(vec![8191, 123456, 127, 7]) == 19);
        assert!(skjkasdkd(vec![127, 97, 8192]) == 10);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/95 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn check_dict_case(dict:HashMap<&str, &str>) -> bool{

if dict.is_empty() {
        return false;
    }

    let mut all_lower = true;
    let mut all_upper = true;

    for key in dict.keys() {
        if !key.chars().all(|c| c.is_lowercase()) {
            all_lower = false;
        }
        if !key.chars().all(|c| c.is_uppercase()) {
            all_upper = false;
        }
    }

    all_lower || all_upper
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_dict_case() {
        assert!(check_dict_case(HashMap::from([("p", "pineapple"), ("b", "banana")])) == true);
        assert!(
            check_dict_case(HashMap::from([
                ("p", "pineapple"),
                ("A", "banana"),
                ("B", "banana")
            ])) == false
        );
        assert!(
            check_dict_case(HashMap::from([
                ("p", "pineapple"),
                ("5", "banana"),
                ("a", "apple")
            ])) == false
        );
        assert!(
            check_dict_case(HashMap::from([
                ("Name", "John"),
                ("Age", "36"),
                ("City", "Houston")
            ])) == false
        );
        assert!(check_dict_case(HashMap::from([("STATE", "NC"), ("ZIP", "12345")])) == true);
        assert!(check_dict_case(HashMap::from([("fruit", "Orange"), ("taste", "Sweet")])) == true);
        assert!(check_dict_case(HashMap::new()) == false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/96 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_up_to(n:i32) -> Vec<i32> {

if n <= 2 {
        return Vec::new();
    }

    let mut primes = Vec::new();
    for num in 2..n {
        if is_prime(num) {
            primes.push(num);
        }
    }
    primes
}

fn is_prime(num: i32) -> bool {
    if num <= 1 {
        return false;
    }
    if num <= 3 {
        return true;
    }
    if num % 2 == 0 || num % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= num {
        if num % i == 0 || num % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_count_up_to() {
        assert!(count_up_to(5) == vec![2, 3]);
        assert!(count_up_to(6) == vec![2, 3, 5]);
        assert!(count_up_to(7) == vec![2, 3, 5]);
        assert!(count_up_to(10) == vec![2, 3, 5, 7]);
        assert!(count_up_to(0) == vec![]);
        assert!(count_up_to(22) == vec![2, 3, 5, 7, 11, 13, 17, 19]);
        assert!(count_up_to(1) == vec![]);
        assert!(count_up_to(18) == vec![2, 3, 5, 7, 11, 13, 17]);
        assert!(count_up_to(47) == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);
        assert!(
            count_up_to(101)
                == vec![
                    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
                    79, 83, 89, 97
                ]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/97 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn multiply(a:i32, b:i32) -> i32{

// Get the unit digit of a
    let unit_digit_a = a.abs() % 10;
    // Get the unit digit of b
    let unit_digit_b = b.abs() % 10;
    // Return the product of the unit digits
    unit_digit_a * unit_digit_b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_multiply() {
        assert!(multiply(148, 412) == 16);
        assert!(multiply(19, 28) == 72);
        assert!(multiply(2020, 1851) == 0);
        assert!(multiply(14, -15) == 20);
        assert!(multiply(76, 67) == 42);
        assert!(multiply(17, 27) == 49);
        assert!(multiply(0, 1) == 0);
        assert!(multiply(0, 0) == 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/98 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_upper(s:&str) -> i32 {

let vowels = ['A', 'E', 'I', 'O', 'U'];
    let mut count = 0;

    for (i, c) in s.chars().enumerate() {
        if i % 2 == 0 && vowels.contains(&c) {
            count += 1;
        }
    }

    count
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_upper() {
        assert!(count_upper("aBCdEf") == 1);
        assert!(count_upper("abcdefg") == 0);
        assert!(count_upper("dBBE") == 0);
        assert!(count_upper("B") == 0);
        assert!(count_upper("U") == 1);
        assert!(count_upper("") == 0);
        assert!(count_upper("EEEE") == 2);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/99 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn closest_integer(value:&str) -> i32 {

// Parse the string to a floating-point number
    let num: f64 = value.parse().expect("Invalid number format");

    // Get the floor and ceiling of the number
    let floor = num.floor();
    let ceil = num.ceil();

    // Calculate the distance to the floor and ceiling
    let dist_to_floor = num - floor;
    let dist_to_ceil = ceil - num;

    // Determine the closest integer, rounding away from zero when equidistant
    if dist_to_floor < dist_to_ceil {
        floor as i32
    } else if dist_to_ceil < dist_to_floor {
        ceil as i32
    } else {
        // Equidistant, round away from zero
        if num > 0.0 {
            ceil as i32
        } else {
            floor as i32
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_closest_integer() {
        assert!(closest_integer("10") == 10);
        assert!(closest_integer("14.5") == 15);
        assert!(closest_integer("-15.5") == -16);
        assert!(closest_integer("15.3") == 15);
        assert!(closest_integer("0") == 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/100 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn make_a_pile(n:i32) -> Vec<i32>{

let mut pile = Vec::with_capacity(n as usize);
    let mut current_stones = n;

    for _ in 0..n {
        pile.push(current_stones);
        if n % 2 == 0 {
            // n is even, so we need the next even number
            current_stones += 2;
        } else {
            // n is odd, so we need the next odd number
            current_stones += 2;
        }
    }

    pile
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_make_a_pile() {
        assert!(make_a_pile(3) == vec![3, 5, 7]);
        assert!(make_a_pile(4) == vec![4, 6, 8, 10]);
        assert!(make_a_pile(5) == vec![5, 7, 9, 11, 13]);
        assert!(make_a_pile(6) == vec![6, 8, 10, 12, 14, 16]);
        assert!(make_a_pile(8) == vec![8, 10, 12, 14, 16, 18, 20, 22]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/101 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn words_string(s:&str) -> Vec<String> {

   [dependencies]
   regex = "1"
   ```

2. Implement the `words_string` function using the `regex` crate to split the string by commas or spaces.

Here's the complete code:


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_words_string() {
        assert!(words_string("Hi, my name is John") == vec!["Hi", "my", "name", "is", "John"]);
        assert!(
            words_string("One, two, three, four, five, six")
                == vec!["One", "two", "three", "four", "five", "six"]
        );
        assert!(words_string("Hi, my name") == vec!["Hi", "my", "name"]);
        assert!(
            words_string("One,, two, three, four, five, six,")
                == vec!["One", "two", "three", "four", "five", "six"]
        );
        let v_empty: Vec<String> = vec![];
        assert!(words_string("") == v_empty);
        assert!(words_string("ahmed , gamal") == vec!["ahmed", "gamal"]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_101_gen0.jsonl

Testing Rust/102 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn choose_num(x:i32, y:i32) -> i32{

// Ensure x is less than or equal to y
    if x > y {
        return -1;
    }

    // Start from the largest number in the range and move downwards
    for num in (x..=y).rev() {
        if num % 2 == 0 {
            return num;
        }
    }

    // If no even number is found, return -1
    -1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_choose_num() {
        assert!(choose_num(12, 15) == 14);
        assert!(choose_num(13, 12) == -1);
        assert!(choose_num(33, 12354) == 12354);
        assert!(choose_num(6, 29) == 28);
        assert!(choose_num(27, 10) == -1);
        assert!(choose_num(7, 7) == -1);
        assert!(choose_num(546, 546) == 546);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/103 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn rounded_avg(n:i32, m:i32) -> String{

if n > m {
        return "-1".to_string();
    }

    // Calculate the sum of integers from n to m
    let count = m - n + 1;
    let sum: i32 = (n..=m).sum();

    // Calculate the average and round it to the nearest integer
    let average = (sum as f64 / count as f64).round() as i32;

    // Convert the rounded average to binary
    format!("{:b}", average)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rounded_avg() {
        assert!(rounded_avg(1, 5) == "11");
        assert!(rounded_avg(7, 13) == "1010");
        assert!(rounded_avg(964, 977) == "1111001010");
        assert!(rounded_avg(996, 997) == "1111100100");
        assert!(rounded_avg(560, 851) == "1011000001");
        assert!(rounded_avg(185, 546) == "101101101");
        assert!(rounded_avg(362, 496) == "110101101");
        assert!(rounded_avg(350, 902) == "1001110010");
        assert!(rounded_avg(197, 233) == "11010111");
        assert!(rounded_avg(7, 5) == "-1");
        assert!(rounded_avg(5, 1) == "-1");
        assert!(rounded_avg(5, 5) == "101");
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_103_gen0.jsonl

Testing Rust/104 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn unique_digits(x:Vec<i32>) -> Vec<i32>{

x.into_iter()
        .filter(|&num| {
            num.to_string()
                .chars()
                .all(|digit| !matches!(digit, '0' | '2' | '4' | '6' | '8'))
        })
        .collect::<Vec<i32>>()
        .sort_unstable();
        x
}

fn unique_digits_corrected(x: Vec<i32>) -> Vec<i32> {
    let mut result: Vec<i32> = x.into_iter()
        .filter(|&num| {
            num.to_string()
                .chars()
                .all(|digit| !matches!(digit, '0' | '2' | '4' | '6' | '8'))
        })
        .collect();
    result.sort_unstable();
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unique_digits() {
        assert!(unique_digits(vec![15, 33, 1422, 1]) == vec![1, 15, 33]);
        assert!(unique_digits(vec![152, 323, 1422, 10]) == vec![]);
        assert!(unique_digits(vec![12345, 2033, 111, 151]) == vec![111, 151]);
        assert!(unique_digits(vec![135, 103, 31]) == vec![31, 135]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_104_gen0.jsonl

Testing Rust/105 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn by_length(arr:Vec<i32>) -> Vec<String>{

// Define a mapping from numbers to their corresponding names
    let number_names = [
        "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"
    ];

    // Filter the array to include only numbers between 1 and 9
    let mut filtered: Vec<i32> = arr.into_iter()
        .filter(|&x| x >= 1 && x <= 9)
        .collect();

    // Sort the filtered numbers
    filtered.sort();

    // Reverse the sorted numbers
    filtered.reverse();

    // Map each number to its corresponding name
    filtered.into_iter()
        .map(|x| number_names[(x - 1) as usize].to_string())
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_by_length() {
        assert!(
            by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])
                == vec!["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
        );
        let v_empty: Vec<String> = vec![];
        assert!(by_length(vec![]) == v_empty);
        assert!(by_length(vec![1, -1, 55]) == vec!["One"]);
        assert!(by_length(vec![1, -1, 3, 2]) == vec!["Three", "Two", "One"]);
        assert!(by_length(vec![9, 4, 8]) == vec!["Nine", "Eight", "Four"]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/106 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn f(n:i32) -> Vec<i32>{

let mut result = Vec::new();
    
    for i in 1..=n {
        if i % 2 == 0 {
            // i is even, calculate factorial
            result.push(factorial(i));
        } else {
            // i is odd, calculate sum from 1 to i
            result.push(sum_to(i));
        }
    }
    
    result
}

fn factorial(num: i32) -> i32 {
    (1..=num).product()
}





fn sum_to(num: i32) -> i32 {
    (1..=num).sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_f() {
        assert!(f(5) == vec![1, 2, 6, 24, 15]);
        assert!(f(7) == vec![1, 2, 6, 24, 15, 720, 28]);
        assert!(f(1) == vec![1]);
        assert!(f(3) == vec![1, 2, 6]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/107 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn even_odd_palindrome(n: i32) -> (i32, i32) {

// Helper function to check if a number is a palindrome

fn is_palindrome(num: i32) -> bool {
        let s = num.to_string();
        s.chars().eq(s.chars().rev())
    }

    let mut even_count = 0;
    let mut odd_count = 0;

    for i in 1..=n {
        if is_palindrome(i) {
            if i % 2 == 0 {
                even_count += 1;
            } else {
                odd_count += 1;
            }
        }
    }

    (even_count, odd_count)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_even_odd_palindrome() {
        assert!(even_odd_palindrome(123) == (8, 13));
        assert!(even_odd_palindrome(12) == (4, 6));
        assert!(even_odd_palindrome(3) == (1, 2));
        assert!(even_odd_palindrome(63) == (6, 8));
        assert!(even_odd_palindrome(25) == (5, 6));
        assert!(even_odd_palindrome(19) == (4, 6));
        assert!(even_odd_palindrome(9) == (4, 5));
        assert!(even_odd_palindrome(1) == (0, 1));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/108 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn count_nums(n:Vec<i32>) -> i32{

n.iter()
        .filter(|&&num| {
            let mut sum = 0;
            let mut num = num;
            let is_negative = num < 0;
            num = num.abs();

            // Process the first digit
            if is_negative {
                sum -= num % 10;
                num /= 10;
            } else {
                sum += num % 10;
                num /= 10;
            }

            // Process the remaining digits
            while num > 0 {
                sum += num % 10;
                num /= 10;
            }

            sum > 0
        })
        .count() as i32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_nums() {
        assert!(count_nums(vec![]) == 0);
        assert!(count_nums(vec![-1, -2, 0]) == 0);
        assert!(count_nums(vec![1, 1, 2, -2, 3, 4, 5]) == 6);
        assert!(count_nums(vec![1, 6, 9, -6, 0, 1, 5]) == 5);
        assert!(count_nums(vec![1, 100, 98, -7, 1, -1]) == 4);
        assert!(count_nums(vec![12, 23, 34, -45, -56, 0]) == 5);
        assert!(count_nums(vec![-0, 1]) == 1);
        assert!(count_nums(vec![1]) == 1);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_108_gen0.jsonl

Testing Rust/109 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn move_one_ball(arr:Vec<i32>) -> bool{

let n = arr.len();
    if n == 0 {
        return true;
    }

    let mut inversion_count = 0;
    let mut inversion_index = None;

    for i in 0..n {
        if arr[i] > arr[(i + 1) % n] {
            inversion_count += 1;
            inversion_index = Some(i);
        }
    }

    if inversion_count == 0 {
        // The array is already sorted
        return true;
    } else if inversion_count == 1 {
        // Check if the array can be rotated to become sorted
        if let Some(index) = inversion_index {
            let mut rotated = arr.clone();
            rotated.rotate_right(index + 1);
            return rotated.windows(2).all(|w| w[0] <= w[1]);
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_move_one_ball() {
        assert!(move_one_ball(vec![3, 4, 5, 1, 2]) == true);
        assert!(move_one_ball(vec![3, 5, 10, 1, 2]) == true);
        assert!(move_one_ball(vec![4, 3, 1, 2]) == false);
        assert!(move_one_ball(vec![3, 5, 4, 1, 2]) == false);
        assert!(move_one_ball(vec![]) == true);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_109_gen0.jsonl

Testing Rust/110 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn exchange(lst1:Vec<i32>, lst2:Vec<i32>) -> String{

// Count the number of odd numbers in lst1
    let odd_count_lst1 = lst1.iter().filter(|&&x| x % 2 != 0).count();
    
    // Count the number of even numbers in lst2
    let even_count_lst2 = lst2.iter().filter(|&&x| x % 2 == 0).count();
    
    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return "YES"
    if even_count_lst2 >= odd_count_lst1 {
        "YES".to_string()
    } else {
        "NO".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exchange() {
        assert!(exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4]) == "YES");
        assert!(exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4]) == "NO");
        assert!(exchange(vec![1, 2, 3, 4], vec![2, 1, 4, 3]) == "YES");
        assert!(exchange(vec![5, 7, 3], vec![2, 6, 4]) == "YES");
        assert!(exchange(vec![5, 7, 3], vec![2, 6, 3]) == "NO");
        assert!(exchange(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]) == "NO");
        assert!(exchange(vec![100, 200], vec![200, 200]) == "YES");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/111 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn histogram(test:&str) -> HashMap<char, i32>{

let mut counts = HashMap::new();

    // Count occurrences of each character
    for c in test.chars().filter(|c| c.is_alphabetic()) {
        *counts.entry(c).or_insert(0) += 1;
    }

    // Find the maximum count
    let max_count = counts.values().cloned().max().unwrap_or(0);

    // Collect characters with the maximum count
    counts.into_iter()
        .filter(|&(_, count)| count == max_count)
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_histogram() {
        assert!(histogram("a b b a") == HashMap::from([('a', 2), ('b', 2)]));
        assert!(histogram("a b c a b") == HashMap::from([('a', 2), ('b', 2)]));
        assert!(
            histogram("a b c d g")
                == HashMap::from([('a', 1), ('b', 1), ('c', 1), ('d', 1), ('g', 1)])
        );
        assert!(histogram("r t g") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));
        assert!(histogram("b b b b a") == HashMap::from([('b', 4)]));
        assert!(histogram("r t g") == HashMap::from([('r', 1), ('t', 1), ('g', 1)]));
        assert!(histogram("") == HashMap::new());
        assert!(histogram("a") == HashMap::from([(('a', 1))]));
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/112 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn reverse_delete(s:&str, c:&str) -> Vec<String> {

// Create a HashSet of characters to delete for faster lookup
    let chars_to_delete: HashSet<char> = c.chars().collect();
    
    // Filter out characters from `s` that are in `chars_to_delete`
    let filtered_string: String = s.chars()
                                  .filter(|&ch| !chars_to_delete.contains(&ch))
                                  .collect();
    
    // Check if the filtered string is a palindrome
    let is_palindrome = filtered_string.chars()
                                       .eq(filtered_string.chars().rev());
    
    // Convert the boolean to a string for the result
    let is_palindrome_str = is_palindrome.to_string();
    
    // Return the result as a vector of strings
    vec![filtered_string, is_palindrome_str]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reverse_delete() {
        assert!(reverse_delete("abcde", "ae") == ["bcd", "False"]);
        assert!(reverse_delete("abcdef", "b") == ["acdef", "False"]);
        assert!(reverse_delete("abcdedcba", "ab") == ["cdedc", "True"]);
        assert!(reverse_delete("dwik", "w") == ["dik", "False"]);
        assert!(reverse_delete("a", "a") == ["", "True"]);
        assert!(reverse_delete("abcdedcba", "") == ["abcdedcba", "True"]);
        assert!(reverse_delete("abcdedcba", "v") == ["abcdedcba", "True"]);
        assert!(reverse_delete("vabba", "v") == ["abba", "True"]);
        assert!(reverse_delete("mamma", "mia") == ["", "True"]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_112_gen0.jsonl

Testing Rust/113 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn odd_count(lst:Vec<&str>) -> Vec<String>{

lst.iter().map(|s| {
        let odd_count = s.chars().filter(|&c| c == '1' || c == '3' || c == '5' || c == '7' || c == '9').count();
        format!("the number of odd elements in the string {} of the input.", odd_count)
    }).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_odd_count() {
        assert!(
            odd_count(vec!["1234567"])
                == ["the number of odd elements 4n the str4ng 4 of the 4nput."]
        );
        assert!(
            odd_count(vec!["3", "11111111"])
                == [
                    "the number of odd elements 1n the str1ng 1 of the 1nput.",
                    "the number of odd elements 8n the str8ng 8 of the 8nput."
                ]
        );
        assert!(
            odd_count(vec!["271", "137", "314"])
                == [
                    "the number of odd elements 2n the str2ng 2 of the 2nput.",
                    "the number of odd elements 3n the str3ng 3 of the 3nput.",
                    "the number of odd elements 2n the str2ng 2 of the 2nput."
                ]
        );
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_113_gen0.jsonl

Testing Rust/114 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn min_sub_array_sum(nums: Vec<i64>) -> i64 {

if nums.is_empty() {
        panic!("The input array should not be empty");
    }

    let mut min_ending_here = nums[0];
    let mut min_so_far = nums[0];

    for &num in nums.iter().skip(1) {
        min_ending_here = cmp::min(num, min_ending_here + num);
        min_so_far = cmp::min(min_so_far, min_ending_here);
    }

    min_so_far
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_sub_array_sum() {
        assert!(min_sub_array_sum(vec![2, 3, 4, 1, 2, 4]) == 1);
        assert!(min_sub_array_sum(vec![-1, -2, -3]) == -6);
        assert!(min_sub_array_sum(vec![-1, -2, -3, 2, -10]) == -14);
        assert!(min_sub_array_sum(vec![-9999999999999999]) == -9999999999999999);
        assert!(min_sub_array_sum(vec![0, 10, 20, 1000000]) == 0);
        assert!(min_sub_array_sum(vec![-1, -2, -3, 10, -5]) == -6);
        assert!(min_sub_array_sum(vec![100, -1, -2, -3, 10, -5]) == -6);
        assert!(min_sub_array_sum(vec![10, 11, 13, 8, 3, 4]) == 3);
        assert!(min_sub_array_sum(vec![100, -33, 32, -1, 0, -2]) == -33);
        assert!(min_sub_array_sum(vec![-10]) == -10);
        assert!(min_sub_array_sum(vec![7]) == 7);
        assert!(min_sub_array_sum(vec![1, -1]) == -1);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/115 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn max_fill(grid:Vec<Vec<i32>>, capacity:i32) -> i32{

// Calculate the total amount of water in all the wells
    let total_water: i32 = grid.iter().flatten().sum();
    
    // Calculate the number of times we need to lower the buckets
    // We use ceiling division to ensure we account for any remaining water
    (total_water + capacity - 1) / capacity
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_fill() {
        assert!(
            max_fill(
                vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]],
                1
            ) == 6
        );
        assert!(
            max_fill(
                vec![
                    vec![0, 0, 1, 1],
                    vec![0, 0, 0, 0],
                    vec![1, 1, 1, 1],
                    vec![0, 1, 1, 1]
                ],
                2
            ) == 5
        );
        assert!(max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5) == 0);
        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 2) == 4);
        assert!(max_fill(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9) == 2);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_115_gen0.jsonl

Testing Rust/116 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sort_array_1(arr:Vec<i32>) -> Vec<i32>{

fn sort_array_1(arr: Vec<i32>) -> Vec<i32> {
    let mut arr = arr;
    arr.sort_unstable_by_key(|&x| (x.count_ones(), x));
    arr
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sort_array_1() {
        assert!(sort_array_1(vec![1, 5, 2, 3, 4]) == vec![1, 2, 4, 3, 5]);
        assert!(sort_array_1(vec![-2, -3, -4, -5, -6]) == vec![-4, -2, -6, -5, -3]);
        assert!(sort_array_1(vec![1, 0, 2, 3, 4]) == vec![0, 1, 2, 4, 3]);
        assert!(sort_array_1(vec![]) == vec![]);
        assert!(
            sort_array_1(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])
                == vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
        );
        assert!(sort_array_1(vec![3, 6, 44, 12, 32, 5]) == vec![32, 3, 5, 6, 12, 44]);
        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);
        assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_116_gen0.jsonl

Testing Rust/117 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn select_words(s:&str, n:i32) -> Vec<String>{

// Define a set of vowels for easy checking
    let vowels: HashSet<char> = "aeiouAEIOU".chars().collect();
    
    // Split the string into words
    s.split_whitespace()
        .filter_map(|word| {
            // Count the number of consonants in the word
            let consonant_count = word.chars().filter(|c| !vowels.contains(c)).count() as i32;
            
            // If the consonant count matches n, return the word as Some(word), otherwise None
            if consonant_count == n {
                Some(word.to_string())
            } else {
                None
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_select_words() {
        assert_eq!(select_words("Mary had a little lamb", 4), vec!["little"]);
        assert_eq!(
            select_words("Mary had a little lamb", 3),
            vec!["Mary", "lamb"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(select_words("simple white space", 2), v_empty);
        assert_eq!(select_words("Hello world", 4), vec!["world"]);
        assert_eq!(select_words("Uncle sam", 3), vec!["Uncle"]);
        assert_eq!(select_words("", 4), v_empty);
        assert_eq!(select_words("a b c d e f", 1), vec!["b", "c", "d", "f"]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/118 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_closest_vowel(word: &str) -> String {

// Define a set of vowels
    let vowels: HashSet<char> = "aeiouAEIOU".chars().collect();
    
    // Convert the word to a character vector for easy indexing
    let chars: Vec<char> = word.chars().collect();
    
    // Iterate from the second last character to the second character
    for i in (1..chars.len() - 1).rev() {
        if vowels.contains(&chars[i]) {
            // Check if the current vowel is between two consonants
            if !vowels.contains(&chars[i - 1]) && !vowels.contains(&chars[i + 1]) {
                return chars[i].to_string();
            }
        }
    }
    
    // Return an empty string if no such vowel is found
    String::new()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_closest_vowel() {
        assert_eq!(get_closest_vowel("yogurt"), "u");
        assert_eq!(get_closest_vowel("full"), "u");
        assert_eq!(get_closest_vowel("easy"), "");
        assert_eq!(get_closest_vowel("eAsy"), "");
        assert_eq!(get_closest_vowel("ali"), "");
        assert_eq!(get_closest_vowel("bad"), "a");
        assert_eq!(get_closest_vowel("most"), "o");
        assert_eq!(get_closest_vowel("ab"), "");
        assert_eq!(get_closest_vowel("ba"), "");
        assert_eq!(get_closest_vowel("quick"), "");
        assert_eq!(get_closest_vowel("anime"), "i");
        assert_eq!(get_closest_vowel("Asia"), "");
        assert_eq!(get_closest_vowel("Above"), "o");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/119 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn match_parens(lst: Vec<&str>) -> &str {

// Helper function to calculate balance and minimum balance

fn calculate_balance(s: &str) -> (i32, i32) {
        let mut balance = 0;
        let mut min_balance = 0;
        for c in s.chars() {
            if c == '(' {
                balance += 1;
            } else {
                balance -= 1;
            }
            min_balance = cmp::min(min_balance, balance);
        }
        (balance, min_balance)
    }

    // Calculate balance and minimum balance for both strings
    let (balance0, min_balance0) = calculate_balance(lst[0]);
    let (balance1, min_balance1) = calculate_balance(lst[1]);

    // Check if lst[0] + lst[1] is balanced
    if min_balance0 + balance1 >= 0 && balance0 + balance1 == 0 {
        return "Yes";
    }

    // Check if lst[1] + lst[0] is balanced
    if min_balance1 + balance0 >= 0 && balance1 + balance0 == 0 {
        return "Yes";
    }

    // If neither concatenation is balanced, return "No"
    "No"
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_match_parens() {
        assert_eq!(match_parens(vec!["()(", ")"]), "Yes");
        assert_eq!(match_parens(vec![")", ")"]), "No");
        assert_eq!(match_parens(vec!["(()(())", "())())"],), "No");
        assert_eq!(match_parens(vec![")())", "(()()("]), "Yes");
        assert_eq!(match_parens(vec!["(())))", "(()())(("]), "Yes");
        assert_eq!(match_parens(vec!["()", "())"],), "No");
        assert_eq!(match_parens(vec!["(()(", "()))()"]), "Yes");
        assert_eq!(match_parens(vec!["((((", "((())"],), "No");
        assert_eq!(match_parens(vec![")(()", "(()("]), "No");
        assert_eq!(match_parens(vec![")(", ")("]), "No");
        assert_eq!(match_parens(vec!["(", ")"]), "Yes");
        assert_eq!(match_parens(vec![")", "("]), "Yes");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/120 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {

fn maximum_120(arr: Vec<i32>, k: i32) -> Vec<i32> {
    if k == 0 {
        return Vec::new();
    }
    
    let k = k as usize;
    let mut heap = BinaryHeap::new();

    for &num in &arr {
        heap.push(num);
        if heap.len() > k {
            heap.pop();
        }
    }

    let mut result = heap.into_sorted_vec();
    result.reverse(); // BinaryHeap is a max-heap, so we need to reverse to get ascending order
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_maximum_120() {
        assert_eq!(maximum_120(vec![-3, -4, 5], 3), vec![-4, -3, 5]);
        assert_eq!(maximum_120(vec![4, -4, 4], 2), vec![4, 4]);
        assert_eq!(maximum_120(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);
        assert_eq!(
            maximum_120(vec![123, -123, 20, 0, 1, 2, -3], 3),
            vec![2, 20, 123]
        );
        assert_eq!(
            maximum_120(vec![-123, 20, 0, 1, 2, -3], 4),
            vec![0, 1, 2, 20]
        );
        assert_eq!(
            maximum_120(vec![5, 15, 0, 3, -13, -8, 0], 7),
            vec![-13, -8, 0, 0, 3, 5, 15]
        );
        assert_eq!(maximum_120(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);
        assert_eq!(maximum_120(vec![1, 0, 5, -7], 1), vec![5]);
        assert_eq!(maximum_120(vec![4, -4], 2), vec![-4, 4]);
        assert_eq!(maximum_120(vec![-10, 10], 2), vec![-10, 10]);
        assert_eq!(maximum_120(vec![1, 2, 3, -23, 243, -400, 0], 0), vec![]);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_120_gen0.jsonl

Testing Rust/121 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solutions(lst: Vec<i32>) -> i32 {

fn solutions(lst: Vec<i32>) -> i32 {
    lst.iter()
        .enumerate()
        .filter(|&(index, &value)| index % 2 == 0 && value % 2 != 0)
        .map(|(_, &value)| value)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solutions() {
        assert_eq!(solutions(vec![5, 8, 7, 1]), 12);
        assert_eq!(solutions(vec![3, 3, 3, 3, 3]), 9);
        assert_eq!(solutions(vec![30, 13, 24, 321]), 0);
        assert_eq!(solutions(vec![5, 9]), 5);
        assert_eq!(solutions(vec![2, 4, 8]), 0);
        assert_eq!(solutions(vec![30, 13, 23, 32]), 23);
        assert_eq!(solutions(vec![3, 13, 2, 9]), 3);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_121_gen0.jsonl

Testing Rust/122 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn add_elements(arr: Vec<i32>, k: i32) -> i32 {

// Iterate through the first k elements of the array
    arr.iter()
        .take(k as usize) // Convert k to usize for the take method
        .filter(|&&x| x.abs() < 100) // Filter elements with at most two digits
        .sum() // Sum the filtered elements
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_elements() {
        assert_eq!(add_elements(vec![1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);
        assert_eq!(add_elements(vec![111, 121, 3, 4000, 5, 6], 2), 0);
        assert_eq!(add_elements(vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);
        assert_eq!(add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);
        assert_eq!(add_elements(vec![1], 1), 1);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/123 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_odd_collatz(n: i32) -> Vec<i32> {

let mut sequence = Vec::new();
    let mut current = n;

    while current != 1 {
        if current % 2 != 0 {
            sequence.push(current);
        }
        if current % 2 == 0 {
            current /= 2;
        } else {
            current = 3 * current + 1;
        }
    }
    // Add 1 to the sequence if it's odd (though it's not necessary as 1 is odd)
    sequence.push(1);

    // Sort the sequence in increasing order
    sequence.sort();
    sequence
}

#[cfg(test)]
mod tests {
    use super::*;

   #[test]
    fn test_get_odd_collatz() {
        assert_eq!(get_odd_collatz(14), vec![1, 5, 7, 11, 13, 17]);
        assert_eq!(get_odd_collatz(5), vec![1, 5]);
        assert_eq!(get_odd_collatz(12), vec![1, 3, 5]);
        assert_eq!(get_odd_collatz(1), vec![1]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/124 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn valid_date(date: &str) -> bool {

[dependencies]
regex = "1"

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_date() {
        assert_eq!(valid_date("03-11-2000"), true);
        assert_eq!(valid_date("15-01-2012"), false);
        assert_eq!(valid_date("04-0-2040"), false);
        assert_eq!(valid_date("06-04-2020"), true);
        assert_eq!(valid_date("01-01-2007"), true);
        assert_eq!(valid_date("03-32-2011"), false);
        assert_eq!(valid_date(""), false);
        assert_eq!(valid_date("04-31-3000"), false);
        assert_eq!(valid_date("06-06-2005"), true);
        assert_eq!(valid_date("21-31-2000"), false);
        assert_eq!(valid_date("04-12-2003"), true);
        assert_eq!(valid_date("04122003"), false);
        assert_eq!(valid_date("20030412"), false);
        assert_eq!(valid_date("2003-04"), false);
        assert_eq!(valid_date("2003-04-12"), false);
        assert_eq!(valid_date("04-2003"), false);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_124_gen0.jsonl

Testing Rust/125 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn split_words(txt: &str) -> Vec<String> {

if txt.contains(char::is_whitespace) {
        // Split by whitespace
        txt.split_whitespace().map(String::from).collect()
    } else if txt.contains(',') {
        // Split by commas
        txt.split(',').map(String::from).collect()
    } else {
        // Count lowercase letters with odd order in the alphabet
        let count = txt.chars()
            .filter(|&c| c.is_ascii_lowercase() && (c as u8 - b'a') % 2 == 1)
            .count();
        vec![count.to_string()]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_split_words() {
        assert_eq!(split_words("Hello world!"), vec!["Hello", "world!"]);
        assert_eq!(split_words("Hello,world!"), vec!["Hello", "world!"]);
        assert_eq!(split_words("Hello world,!"), vec!["Hello", "world,!"]);
        assert_eq!(
            split_words("Hello,Hello,world !"),
            vec!["Hello,Hello,world", "!"]
        );
        assert_eq!(split_words("abcdef"), vec!["3"]);
        assert_eq!(split_words("aaabb"), vec!["2"]);
        assert_eq!(split_words("aaaBb"), vec!["1"]);
        assert_eq!(split_words(""), vec!["0"]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/126 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_sorted(lst: Vec<i32>) -> bool {

let mut seen = HashSet::new();
    
    for (i, &value) in lst.iter().enumerate() {
        if seen.contains(&value) {
            return false; // More than one duplicate found
        }
        seen.insert(value);
        
        if i > 0 && lst[i - 1] >= value {
            return false; // Not sorted in ascending order
        }
    }
    
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_sorted() {
        assert_eq!(is_sorted(vec![5]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5]), true);
        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5]), false);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4, 5, 6, 7]), true);
        assert_eq!(is_sorted(vec![1, 3, 2, 4, 5, 6, 7]), false);
        assert_eq!(is_sorted(vec![]), true);
        assert_eq!(is_sorted(vec![1]), true);
        assert_eq!(is_sorted(vec![3, 2, 1]), false);
        assert_eq!(is_sorted(vec![1, 2, 2, 2, 3, 4]), false);
        assert_eq!(is_sorted(vec![1, 2, 3, 3, 3, 4]), false);
        assert_eq!(is_sorted(vec![1, 2, 2, 3, 3, 4]), true);
        assert_eq!(is_sorted(vec![1, 2, 3, 4]), true);
    }


}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_126_gen0.jsonl

Testing Rust/127 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn intersection(interval1: Vec<i32>, interval2: Vec<i32>) -> String {

// Extract start and end points of the intervals
    let start1 = interval1[0];
    let end1 = interval1[1];
    let start2 = interval2[0];
    let end2 = interval2[1];
    
    // Calculate the intersection
    let intersection_start = std::cmp::max(start1, start2);
    let intersection_end = std::cmp::min(end1, end2);
    
    // Check if there is an intersection
    if intersection_start > intersection_end {
        return "NO".to_string();
    }
    
    // Calculate the length of the intersection
    let intersection_length = intersection_end - intersection_start + 1;
    
    // Check if the length is a prime number
    if is_prime(intersection_length) {
        "YES".to_string()
    } else {
        "NO".to_string()
    }
}

fn is_prime(n: i32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_intersection() {
        assert_eq!(intersection(vec![1, 2], vec![2, 3]), "NO");
        assert_eq!(intersection(vec![-1, 1], vec![0, 4]), "NO");
        assert_eq!(intersection(vec![-3, -1], vec![-5, 5]), "YES");
        assert_eq!(intersection(vec![-2, 2], vec![-4, 0]), "YES");
        assert_eq!(intersection(vec![-11, 2], vec![-1, -1]), "NO");
        assert_eq!(intersection(vec![1, 2], vec![3, 5]), "NO");
        assert_eq!(intersection(vec![1, 2], vec![1, 2]), "NO");
        assert_eq!(intersection(vec![-2, -2], vec![-3, -2]), "NO");
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_127_gen0.jsonl

Testing Rust/128 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn prod_signs(arr: Vec<i32>) -> i32 {

if arr.is_empty() {
        return None;
    }

    let mut sum_of_magnitudes = 0;
    let mut product_of_signs = 1;

    for &num in &arr {
        sum_of_magnitudes += num.abs();
        product_of_signs *= match num {
            0 => 0,
            _ if num > 0 => 1,
            _ => -1,
        };
    }

    Some(sum_of_magnitudes * product_of_signs)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prod_signs() {
        assert_eq!(prod_signs(vec![1, 2, 2, -4]), -9);
        assert_eq!(prod_signs(vec![0, 1]), 0);
        assert_eq!(prod_signs(vec![1, 1, 1, 2, 3, -1, 1]), -10);
        assert_eq!(prod_signs(vec![]), -32768);
        assert_eq!(prod_signs(vec![2, 4, 1, 2, -1, -1, 9]), 20);
        assert_eq!(prod_signs(vec![-1, 1, -1, 1]), 4);
        assert_eq!(prod_signs(vec![-1, 1, 1, 1]), -4);
        assert_eq!(prod_signs(vec![-1, 1, 1, 0]), 0);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_128_gen0.jsonl

Testing Rust/129 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn min_path(grid: Vec<Vec<i32>>, k: i32) -> Vec<i32> {

let n = grid.len();
    let k = k as usize;
    let mut min_path = vec![i32::MAX; k];

    // Directions for moving in the grid: right, down, left, up
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];

fn dfs(
        grid: &Vec<Vec<i32>>,
        x: usize,
        y: usize,
        k: usize,
        path: &mut Vec<i32>,
        min_path: &mut Vec<i32>,
        visited: &mut Vec<Vec<bool>>,
        directions: &[(isize, isize)],
    ) {
        if path.len() == k {
            if path < min_path {
                *min_path = path.clone();
            }
            return;
        }

        for &(dx, dy) in directions {
            let nx = x as isize + dx;
            let ny = y as isize + dy;
            if nx >= 0 && nx < grid.len() as isize && ny >= 0 && ny < grid[0].len() as isize {
                let nx = nx as usize;
                let ny = ny as usize;
                if !visited[nx][ny] {
                    visited[nx][ny] = true;
                    path.push(grid[nx][ny]);
                    dfs(grid, nx, ny, k, path, min_path, visited, directions);
                    path.pop();
                    visited[nx][ny] = false;
                }
            }
        }
    }

    for i in 0..n {
        for j in 0..n {
            let mut path = vec![grid[i][j]];
            let mut visited = vec![vec![false; n]; n];
            visited[i][j] = true;
            dfs(&grid, i, j, k, &mut path, &mut min_path, &mut visited, &directions);
        }
    }

    min_path
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_min_path() {
        assert_eq!(
            min_path(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3),
            vec![1, 2, 1]
        );
        assert_eq!(
            min_path(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1),
            vec![1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![1, 2, 3, 4],
                    vec![5, 6, 7, 8],
                    vec![9, 10, 11, 12],
                    vec![13, 14, 15, 16]
                ],
                4
            ),
            vec![1, 2, 1, 2]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![6, 4, 13, 10],
                    vec![5, 7, 12, 1],
                    vec![3, 16, 11, 15],
                    vec![8, 14, 9, 2]
                ],
                7
            ),
            vec![1, 10, 1, 10, 1, 10, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![8, 14, 9, 2],
                    vec![6, 4, 13, 15],
                    vec![5, 7, 1, 12],
                    vec![3, 10, 11, 16]
                ],
                5
            ),
            vec![1, 7, 1, 7, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![11, 8, 7, 2],
                    vec![5, 16, 14, 4],
                    vec![9, 3, 15, 6],
                    vec![12, 13, 10, 1]
                ],
                9
            ),
            vec![1, 6, 1, 6, 1, 6, 1, 6, 1]
        );
        assert_eq!(
            min_path(
                vec![
                    vec![12, 13, 10, 1],
                    vec![9, 3, 15, 6],
                    vec![5, 16, 14, 4],
                    vec![11, 8, 7, 2]
                ],
                12
            ),
            vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
        );
        assert_eq!(
            min_path(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8),
            vec![1, 3, 1, 3, 1, 3, 1, 3]
        );

        assert_eq!(
            min_path(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8),
            vec![1, 5, 1, 5, 1, 5, 1, 5]
        );

        assert_eq!(
            min_path(vec![vec![1, 2], vec![3, 4]], 10),
            vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
        );

        assert_eq!(
            min_path(vec![vec![1, 3], vec![3, 2]], 10),
            vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]
        );
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_129_gen0.jsonl

Testing Rust/130 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn tri(n: i32) -> Vec<i32> {

if n < 0 {
        return vec![];
    }

    let mut sequence = vec![0; (n + 1) as usize];
    sequence[0] = 3; // tri(1) = 3

    for i in 1..=n {
        if i % 2 == 0 {
            sequence[i as usize] = 1 + i / 2;
        } else {
            if i == 1 {
                sequence[i as usize] = 3;
            } else {
                let next_index = (i + 1) as usize;
                if next_index > sequence.len() - 1 {
                    sequence.push(0);
                }
                sequence[i as usize] = sequence[(i - 1) as usize] + sequence[(i - 2) as usize] + sequence[next_index];
            }
        }
    }

    sequence
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tri() {
        assert!(tri(3) == vec![1, 3, 2, 8]);
        assert!(tri(4) == vec![1, 3, 2, 8, 3]);
        assert!(tri(5) == vec![1, 3, 2, 8, 3, 15]);
        assert!(tri(6) == vec![1, 3, 2, 8, 3, 15, 4]);
        assert!(tri(7) == vec![1, 3, 2, 8, 3, 15, 4, 24]);
        assert!(tri(8) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5]);
        assert!(tri(9) == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35]);
        assert!(
            tri(20)
                == vec![1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11]
        );
        assert!(tri(0) == vec![1]);
        assert!(tri(1) == vec![1, 3]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_130_gen0.jsonl

Testing Rust/131 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn digits(n: i32) -> i32 {

let mut product = 1;
    let mut has_odd_digit = false;
    let mut num = n;

    while num > 0 {
        let digit = num % 10;
        if digit % 2 != 0 {
            product *= digit;
            has_odd_digit = true;
        }
        num /= 10;
    }

    if has_odd_digit {
        product
    } else {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_digits() {
        assert_eq!(digits(5), 5);
        assert_eq!(digits(54), 5);
        assert_eq!(digits(120), 1);
        assert_eq!(digits(5014), 5);
        assert_eq!(digits(98765), 315);
        assert_eq!(digits(5576543), 2625);
        assert_eq!(digits(2468), 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/132 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_nested(str: &str) -> bool {

let mut balance = 0;
    let mut has_nested = false;

    for c in s.chars() {
        match c {
            '[' => balance += 1,
            ']' => {
                if balance > 0 {
                    balance -= 1;
                    if balance > 0 {
                        has_nested = true;
                    }
                } else {
                    // More closing brackets than opening brackets
                    return false;
                }
            }
            _ => unreachable!(), // Since the input is guaranteed to contain only square brackets
        }
    }

    // If balance is not zero, there are unmatched opening brackets
    balance == 0 && has_nested
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_nested() {
        assert_eq!(is_nested("[[]]"), true);
        assert_eq!(is_nested("[]]]]]]][[[[[]"), false);
        assert_eq!(is_nested("[][]"), false);
        assert_eq!(is_nested("[]"), false);
        assert_eq!(is_nested("[[[[]]]]"), true);
        assert_eq!(is_nested("[]]]]]]]]]]"), false);
        assert_eq!(is_nested("[][][[]]"), true);
        assert_eq!(is_nested("[[]"), false);
        assert_eq!(is_nested("[]]"), false);
        assert_eq!(is_nested("[[]][["), true);
        assert_eq!(is_nested("[[][]]"), true);
        assert_eq!(is_nested(""), false);
        assert_eq!(is_nested("[[[[[[[["), false);
        assert_eq!(is_nested("]]]]]]]]"), false);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_132_gen0.jsonl

Testing Rust/133 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_squares(lst: Vec<f32>) -> i32 {

lst.iter().enumerate().map(|(index, &value)| {
        if index % 3 == 0 {
            (value.powi(2)) as i32
        } else if index % 4 == 0 {
            (value.powi(3)) as i32
        } else {
            value as i32
        }
    }).sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_squares() {
        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);
        assert_eq!(sum_squares(vec![1.0, 2.0, 3.0]), 14);
        assert_eq!(sum_squares(vec![1.0, 3.0, 5.0, 7.0]), 84);
        assert_eq!(sum_squares(vec![1.4, 4.2, 0.0]), 29);
        assert_eq!(sum_squares(vec![-2.4, 1.0, 1.0]), 6);
        assert_eq!(sum_squares(vec![100.0, 1.0, 15.0, 2.0]), 10230);
        assert_eq!(sum_squares(vec![10000.0, 10000.0]), 200000000);
        assert_eq!(sum_squares(vec![-1.4, 4.6, 6.3]), 75);
        assert_eq!(sum_squares(vec![-1.4, 17.9, 18.9, 19.9]), 1086);
        assert_eq!(sum_squares(vec![0.0]), 0);
        assert_eq!(sum_squares(vec![-1.0]), 1);
        assert_eq!(sum_squares(vec![-1.0, 1.0, 0.0]), 2);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_133_gen0.jsonl

Testing Rust/134 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn check_if_last_char_is_a_letter(txt: &str) -> bool {

// Trim any trailing whitespace from the string
    let trimmed_txt = txt.trim_end();
    
    // Check if the trimmed string is empty
    if trimmed_txt.is_empty() {
        return false;
    }
    
    // Get the last character of the trimmed string
    let last_char = trimmed_txt.chars().last().unwrap();
    
    // Check if the last character is an alphabetical character
    if !last_char.is_alphabetic() {
        return false;
    }
    
    // Check if the last character is not part of a word
    // This means the character before the last character should be a space
    // or the last character should be the only character in the string
    if trimmed_txt.len() == 1 || trimmed_txt.chars().nth(trimmed_txt.len() - 2) == Some(' ') {
        return true;
    }
    
    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_if_last_char_is_a_letter() {
        assert_eq!(check_if_last_char_is_a_letter("apple"), false);
        assert_eq!(check_if_last_char_is_a_letter("apple pi e"), true);
        assert_eq!(check_if_last_char_is_a_letter("eeeee"), false);
        assert_eq!(check_if_last_char_is_a_letter("A"), true);
        assert_eq!(check_if_last_char_is_a_letter("Pumpkin pie "), false);
        assert_eq!(check_if_last_char_is_a_letter("Pumpkin pie 1"), false);
        assert_eq!(check_if_last_char_is_a_letter(""), false);
        assert_eq!(check_if_last_char_is_a_letter("eeeee e "), false);
        assert_eq!(check_if_last_char_is_a_letter("apple pie"), false);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_134_gen0.jsonl

Testing Rust/135 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn can_arrange(arr: Vec<i32>) -> i32 {

let mut largest_index = -1;
    
    for i in 1..arr.len() {
        if arr[i] < arr[i - 1] {
            largest_index = i as i32;
        }
    }
    
    largest_index
}

#[cfg(test)]
mod tests {
    use super::*;


    #[test]
    fn test_can_arrange() {
        assert_eq!(can_arrange(vec![1, 2, 4, 3, 5]), 3);
        assert_eq!(can_arrange(vec![1, 2, 4, 5]), -1);
        assert_eq!(can_arrange(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);
        assert_eq!(can_arrange(vec![4, 8, 5, 7, 3]), 4);
        assert_eq!(can_arrange(vec![]), -1);
    }


}

-----CODE END-----
Generation 1: PASSED

Testing Rust/136 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn largest_smallest_integers(lst: Vec<i32>) -> Vec<i32> {

let mut largest_negative: Option<i32> = None;
    let mut smallest_positive: Option<i32> = None;

    for &num in &lst {
        if num < 0 {
            largest_negative = Some(match largest_negative {
                Some(current_max) => cmp::max(current_max, num),
                None => num,
            });
        } else if num > 0 {
            smallest_positive = Some(match smallest_positive {
                Some(current_min) => cmp::min(current_min, num),
                None => num,
            });
        }
    }

    let largest_negative = largest_negative.unwrap_or(i32::MIN);
    let smallest_positive = smallest_positive.unwrap_or(i32::MAX);

    vec![largest_negative, smallest_positive]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_largest_smallest_integers() {
        assert_eq!(
            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7]),
            vec![0, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![2, 4, 1, 3, 5, 7, 0]),
            vec![0, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![1, 3, 2, 4, 5, 6, -2]),
            vec![-2, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![4, 5, 3, 6, 2, 7, -7]),
            vec![-7, 2]
        );
        assert_eq!(
            largest_smallest_integers(vec![7, 3, 8, 4, 9, 2, 5, -9]),
            vec![-9, 2]
        );
        assert_eq!(largest_smallest_integers(vec![]), vec![0, 0]);
        assert_eq!(largest_smallest_integers(vec![0]), vec![0, 0]);
        assert_eq!(largest_smallest_integers(vec![-1, -3, -5, -6]), vec![-1, 0]);
        assert_eq!(
            largest_smallest_integers(vec![-1, -3, -5, -6, 0]),
            vec![-1, 0]
        );
        assert_eq!(
            largest_smallest_integers(vec![-6, -4, -4, -3, 1]),
            vec![-3, 1]
        );
        assert_eq!(
            largest_smallest_integers(vec![-6, -4, -4, -3, -100, 1]),
            vec![-3, 1]
        );
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_136_gen0.jsonl

Testing Rust/138 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn is_equal_to_sum_even(n: i32) -> bool {

// Check if n is even and at least 8
    n >= 8 && n % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_equal_to_sum_even() {
        assert_eq!(is_equal_to_sum_even(4), false);
        assert_eq!(is_equal_to_sum_even(6), false);
        assert_eq!(is_equal_to_sum_even(8), true);
        assert_eq!(is_equal_to_sum_even(10), true);
        assert_eq!(is_equal_to_sum_even(11), false);
        assert_eq!(is_equal_to_sum_even(12), true);
        assert_eq!(is_equal_to_sum_even(13), false);
        assert_eq!(is_equal_to_sum_even(16), true);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/139 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn special_factorial(n: i32) -> i64 {

if n <= 0 {
        panic!("n must be greater than 0");
    }

    let mut result: i64 = 1;
    let mut factorial: i64 = 1;

    for i in 1..=n {
        factorial *= i as i64;
        result *= factorial;
        if result < 0 {
            panic!("Overflow occurred");
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_special_factorial() {
        assert_eq!(special_factorial(4), 288);
        assert_eq!(special_factorial(5), 34560);
        assert_eq!(special_factorial(7), 125411328000);
        assert_eq!(special_factorial(1), 1);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/140 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn fix_spaces(text: &str) -> String {

let mut result = String::new();
    let mut space_count = 0;

    for c in text.chars() {
        if c == ' ' {
            space_count += 1;
        } else {
            if space_count > 2 {
                result.push('-');
            } else {
                result.extend(std::iter::repeat('_').take(space_count));
            }
            result.push(c);
            space_count = 0;
        }
    }

    // Handle trailing spaces
    if space_count > 2 {
        result.push('-');
    } else {
        result.extend(std::iter::repeat('_').take(space_count));
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fix_spaces() {
        assert_eq!(fix_spaces("Example"), "Example");
        assert_eq!(fix_spaces("Mudasir Hanif "), "Mudasir_Hanif_");
        assert_eq!(
            fix_spaces("Yellow Yellow  Dirty  Fellow"),
            "Yellow_Yellow__Dirty__Fellow"
        );
        assert_eq!(fix_spaces("Exa   mple"), "Exa-mple");
        assert_eq!(fix_spaces("   Exa 1 2 2 mple"), "-Exa_1_2_2_mple");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/141 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn file_name_check(file_name: &str) -> &str {

// Check for exactly one dot
    let parts: Vec<&str> = file_name.split('.').collect();
    if parts.len() != 2 {
        return "No";
    }

    let (name, extension) = (parts[0], parts[1]);

    // Check if the name part is not empty and starts with a letter
    if name.is_empty() || !name.chars().next().unwrap().is_alphabetic() {
        return "No";
    }

    // Check if the extension is one of the allowed ones
    let valid_extensions = ["txt", "exe", "dll"];
    if !valid_extensions.contains(&extension) {
        return "No";
    }

    // Check for no more than three digits in the name part
    let digit_count = name.chars().filter(|c| c.is_digit(10)).count();
    if digit_count > 3 {
        return "No";
    }

    "Yes"
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_file_name_check() {
        assert_eq!(file_name_check("example.txt"), "Yes");
        assert_eq!(file_name_check("1example.dll"), "No");
        assert_eq!(file_name_check("s1sdf3.asd"), "No");
        assert_eq!(file_name_check("K.dll"), "Yes");
        assert_eq!(file_name_check("MY16FILE3.exe"), "Yes");
        assert_eq!(file_name_check("His12FILE94.exe"), "No");
        assert_eq!(file_name_check("_Y.txt"), "No");
        assert_eq!(file_name_check("?aREYA.exe"), "No");
        assert_eq!(file_name_check("/this_is_valid.dll"), "No");
        assert_eq!(file_name_check("this_is_valid.wow"), "No");
        assert_eq!(file_name_check("this_is_valid.txt"), "Yes");
        assert_eq!(file_name_check("this_is_valid.txtexe"), "No");
        assert_eq!(file_name_check("#this2_i4s_5valid.ten"), "No");
        assert_eq!(file_name_check("@this1_is6_valid.exe"), "No");
        assert_eq!(file_name_check("this_is_12valid.6exe4.txt"), "No");
        assert_eq!(file_name_check("all.exe.txt"), "No");
        assert_eq!(file_name_check("I563_No.exe"), "Yes");
        assert_eq!(file_name_check("Is3youfault.txt"), "Yes");
        assert_eq!(file_name_check("no_one#knows.dll"), "Yes");
        assert_eq!(file_name_check("1I563_Yes3.exe"), "No");
        assert_eq!(file_name_check("I563_Yes3.txtt"), "No");
        assert_eq!(file_name_check("final..txt"), "No");
        assert_eq!(file_name_check("final132"), "No");
        assert_eq!(file_name_check("_f4indsartal132."), "No");
        assert_eq!(file_name_check(".txt"), "No");
        assert_eq!(file_name_check("s."), "No");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/142 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sum_squares_142(lst: Vec<i32>) -> i32 {

fn sum_squares_142(lst: Vec<i32>) -> i32 {
    lst.iter().enumerate().map(|(index, &value)| {
        if index % 3 == 0 {
            value.pow(2)
        } else if index % 4 == 0 {
            value.pow(3)
        } else {
            value
        }
    }).sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sum_squares_142() {
        assert_eq!(sum_squares_142(vec![1, 2, 3]), 6);
        assert_eq!(sum_squares_142(vec![1, 4, 9]), 14);
        assert_eq!(sum_squares_142(vec![]), 0);
        assert_eq!(sum_squares_142(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);
        assert_eq!(
            sum_squares_142(vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]),
            -3
        );
        assert_eq!(sum_squares_142(vec![0]), 0);
        assert_eq!(sum_squares_142(vec![-1, -5, 2, -1, -5]), -126);
        assert_eq!(sum_squares_142(vec![-56, -99, 1, 0, -2]), 3030);
        assert_eq!(sum_squares_142(vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);
        assert_eq!(
            sum_squares_142(vec![
                -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37
            ]),
            -14196
        );
        assert_eq!(
            sum_squares_142(vec![
                -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10
            ]),
            -1448
        );
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_142_gen0.jsonl

Testing Rust/143 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn words_in_sentence(sentence: &str) -> String {

sentence
        .split_whitespace()
        .filter(|word| is_prime(word.len()))
        .collect::<Vec<&str>>()
        .join(" ")
}

fn is_prime(n: usize) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}





#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_words_in_sentence() {
        assert_eq!(words_in_sentence("This is a test"), "is");
        assert_eq!(words_in_sentence("lets go for swimming"), "go for");
        assert_eq!(
            words_in_sentence("there is no place available here"),
            "there is no place"
        );
        assert_eq!(words_in_sentence("Hi I am Hussein"), "Hi am Hussein");
        assert_eq!(words_in_sentence("go for it"), "go for it");
        assert_eq!(words_in_sentence("here"), "");
        assert_eq!(words_in_sentence("here is"), "is");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/144 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn simplify(x: &str, n: &str) -> bool {

// Helper function to parse a fraction string into a tuple of (numerator, denominator)

fn parse_fraction(fraction: &str) -> (u32, u32) {
        let parts: Vec<&str> = fraction.split('/').collect();
        let numerator: u32 = parts[0].parse().unwrap();
        let denominator: u32 = parts[1].parse().unwrap();
        (numerator, denominator)
    }

    // Parse the input fractions
    let (x_num, x_den) = parse_fraction(x);
    let (n_num, n_den) = parse_fraction(n);

    // Multiply the numerators and denominators
    let result_num = x_num * n_num;
    let result_den = x_den * n_den;

    // Check if the resulting fraction is a whole number
    result_num % result_den == 0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simplify() {
        assert_eq!(simplify("1/5", "5/1"), true);
        assert_eq!(simplify("1/6", "2/1"), false);
        assert_eq!(simplify("5/1", "3/1"), true);
        assert_eq!(simplify("7/10", "10/2"), false);
        assert_eq!(simplify("2/10", "50/10"), true);
        assert_eq!(simplify("7/2", "4/2"), true);
        assert_eq!(simplify("11/6", "6/1"), true);
        assert_eq!(simplify("2/3", "5/2"), false);
        assert_eq!(simplify("5/2", "3/5"), false);
        assert_eq!(simplify("2/4", "8/4"), true);
        assert_eq!(simplify("2/4", "4/2"), true);
        assert_eq!(simplify("1/5", "5/1"), true);
        assert_eq!(simplify("1/5", "1/5"), false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/145 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn order_by_points(arr: Vec<i32>) -> Vec<i32> {

// Helper function to calculate the sum of digits of a number

fn digit_sum(n: i32) -> i32 {
        n.abs().to_string().chars().map(|c| c.to_digit(10).unwrap() as i32).sum()
    }

    // Create a vector of tuples (digit_sum, index, value)
    let mut indexed_arr: Vec<(i32, usize, i32)> = arr.iter().enumerate().map(|(i, &val)| (digit_sum(val), i, val)).collect();

    // Sort the vector of tuples by digit_sum, then by index
    indexed_arr.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));

    // Extract the sorted values
    indexed_arr.into_iter().map(|(_, _, val)| val).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order_by_points() {
        assert_eq!(
            order_by_points(vec![1, 11, -1, -11, -12]),
            vec![-1, -11, 1, -12, 11]
        );
        assert_eq!(
            order_by_points(vec![
                1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46
            ]),
            vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
        );
        assert_eq!(order_by_points(vec![]), vec![]);
        assert_eq!(
            order_by_points(vec![1, -11, -32, 43, 54, -98, 2, -3]),
            vec![-3, -32, -98, -11, 1, 2, 43, 54]
        );
        assert_eq!(
            order_by_points(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),
            vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
        );
        assert_eq!(
            order_by_points(vec![0, 6, 6, -76, -21, 23, 4]),
            vec![-76, -21, 0, 4, 23, 6, 6]
        );
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_145_gen0.jsonl

Testing Rust/146 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn special_filter(nums: Vec<i32>) -> i32 {

// Helper function to check if a digit is odd

fn is_odd_digit(digit: char) -> bool {
        matches!(digit, '1' | '3' | '5' | '7' | '9')
    }

    // Helper function to get the first and last digits of a number
    



fn get_first_and_last_digits(num: i32) -> (char, char) {
        let num_str = num.to_string();
        let first_digit = num_str.chars().next().unwrap();
        let last_digit = num_str.chars().last().unwrap();
        (first_digit, last_digit)
    }

    nums.iter()
        .filter(|&&num| num > 10)
        .filter(|&&num| {
            let (first_digit, last_digit) = get_first_and_last_digits(num);
            is_odd_digit(first_digit) && is_odd_digit(last_digit)
        })
        .count() as i32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_special_filter() {
        assert_eq!(special_filter(vec![5, -2, 1, -5]), 0);
        assert_eq!(special_filter(vec![15, -73, 14, -15]), 1);
        assert_eq!(special_filter(vec![33, -2, -3, 45, 21, 109]), 2);
        assert_eq!(special_filter(vec![43, -12, 93, 125, 121, 109]), 4);
        assert_eq!(special_filter(vec![71, -2, -33, 75, 21, 19]), 3);
        assert_eq!(special_filter(vec![1]), 0);
        assert_eq!(special_filter(vec![]), 0);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/147 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn get_matrix_triples(n: i32) -> i32 {

// Create the array a
    let mut a = Vec::new();
    for i in 1..=n {
        a.push(i * i - i + 1);
    }

    // Count the remainders when divided by 3
    let mut count = [0; 3];
    for &value in &a {
        count[(value % 3) as usize] += 1;
    }

    // Calculate the number of valid triples
    let mut result = 0;

    // Case 1: All three numbers have remainder 0
    result += count[0] * (count[0] - 1) * (count[0] - 2) / 6;

    // Case 2: All three numbers have remainder 1
    result += count[1] * (count[1] - 1) * (count[1] - 2) / 6;

    // Case 3: All three numbers have remainder 2
    result += count[2] * (count[2] - 1) * (count[2] - 2) / 6;

    // Case 4: One number from each remainder group
    result += count[0] * count[1] * count[2];

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_matrix_triples() {
        assert_eq!(get_matrix_triples(5), 1);
        assert_eq!(get_matrix_triples(6), 4);
        assert_eq!(get_matrix_triples(10), 36);
        assert_eq!(get_matrix_triples(100), 53361);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/148 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn bf(planet1: &str, planet2: &str) -> Vec<String> {

// Define the order of the planets in the solar system
    let planets = vec![
        "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"
    ];

    // Find the indices of the given planets
    let index1 = planets.iter().position(|&p| p == planet1);
    let index2 = planets.iter().position(|&p| p == planet2);

    // If either planet is not found, return an empty vector
    if index1.is_none() || index2.is_none() {
        return Vec::new();
    }

    let index1 = index1.unwrap();
    let index2 = index2.unwrap();

    // Determine the range between the two indices
    let (start, end) = if index1 < index2 {
        (index1 + 1, index2)
    } else {
        (index2 + 1, index1)
    };

    // Collect the planets between the two indices
    planets[start..end].to_vec()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bf() {
        assert_eq!(bf("Jupiter", "Neptune"), vec!["Saturn", "Uranus"]);
        assert_eq!(bf("Earth", "Mercury"), vec!["Venus"]);
        assert_eq!(
            bf("Mercury", "Uranus"),
            vec!["Venus", "Earth", "Mars", "Jupiter", "Saturn"]
        );
        assert_eq!(
            bf("Neptune", "Venus"),
            vec!["Earth", "Mars", "Jupiter", "Saturn", "Uranus"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(bf("Earth", "Earth"), v_empty);
        assert_eq!(bf("Mars", "Earth"), v_empty);
        assert_eq!(bf("Jupiter", "Makemake"), v_empty);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_148_gen0.jsonl

Testing Rust/149 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn sorted_list_sum(lst: Vec<&str>) -> Vec<&str> {

// Filter out strings with odd lengths
    let mut filtered: Vec<&str> = lst.into_iter().filter(|s| s.len() % 2 == 0).collect();
    
    // Sort the filtered list by length, then alphabetically
    filtered.sort_by(|a, b| {
        a.len().cmp(&b.len()).then_with(|| a.cmp(b))
    });
    
    filtered
}

#[cfg(test)]
mod tests {
    use super::*;

   #[test]
    fn test_sorted_list_sum() {
        assert_eq!(sorted_list_sum(vec!["aa", "a", "aaa"]), vec!["aa"]);
        assert_eq!(
            sorted_list_sum(vec!["school", "AI", "asdf", "b"]),
            vec!["AI", "asdf", "school"]
        );
        let v_empty: Vec<&str> = vec![];
        assert_eq!(sorted_list_sum(vec!["d", "b", "c", "a"]), v_empty);
        assert_eq!(
            sorted_list_sum(vec!["d", "dcba", "abcd", "a"]),
            vec!["abcd", "dcba"]
        );
        assert_eq!(
            sorted_list_sum(vec!["AI", "ai", "au"]),
            vec!["AI", "ai", "au"]
        );
        assert_eq!(sorted_list_sum(vec!["a", "b", "b", "c", "c", "a"]), v_empty);
        assert_eq!(
            sorted_list_sum(vec!["aaaa", "bbbb", "dd", "cc"]),
            vec!["cc", "dd", "aaaa", "bbbb"]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/150 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn x_or_y(n: i32, x: i32, y: i32) -> i32 {

if is_prime(n) {
        x
    } else {
        y
    }
}

fn is_prime(n: i32) -> bool {
    if n <= 1 {
        return false;
    }
    if n <= 3 {
        return true;
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false;
    }
    let mut i = 5;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_x_or_y() {
        assert_eq!(x_or_y(7, 34, 12), 34);
        assert_eq!(x_or_y(15, 8, 5), 5);
        assert_eq!(x_or_y(3, 33, 5212), 33);
        assert_eq!(x_or_y(1259, 3, 52), 3);
        assert_eq!(x_or_y(7919, -1, 12), -1);
        assert_eq!(x_or_y(3609, 1245, 583), 583);
        assert_eq!(x_or_y(91, 56, 129), 129);
        assert_eq!(x_or_y(6, 34, 1234), 1234);
        assert_eq!(x_or_y(1, 2, 0), 0);
        assert_eq!(x_or_y(2, 2, 0), 2);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/151 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn double_the_difference(lst: Vec<f32>) -> i64 {

lst.into_iter()
        .filter(|&x| x.fract() == 0.0 && x > 0.0 && (x as i64) % 2 != 0)
        .map(|x| (x as i64).pow(2))
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_double_the_difference() {
        assert_eq!(double_the_difference(vec![]), 0);
        assert_eq!(double_the_difference(vec![5.0, 4.0]), 25);
        assert_eq!(double_the_difference(vec![0.1, 0.2, 0.3]), 0);
        assert_eq!(double_the_difference(vec![-10.0, -20.0, -30.0]), 0);
        assert_eq!(double_the_difference(vec![-1.0, -2.0, 8.0]), 0);
        assert_eq!(double_the_difference(vec![0.2, 3.0, 5.0]), 34);

        let mut lst = vec![];
        let mut odd_sum = 0;
        for i in -99..100 {
            lst.push(i as f32);
            if i > 0 && i % 2 == 1 {
                odd_sum += i * i;
            }
        }
        assert_eq!(double_the_difference(lst), odd_sum);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/152 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn compare(game: Vec<i32>, guess: Vec<i32>) -> Vec<i32> {

game.iter()
        .zip(guess.iter())
        .map(|(&g, &gu)| (g - gu).abs())
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compare() {
        assert_eq!(
            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),
            vec![0, 0, 0, 0, 3, 3]
        );
        assert_eq!(
            compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2]),
            vec![4, 4, 1, 0, 0, 6]
        );
        assert_eq!(
            compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2]),
            vec![0, 0, 0, 0, 3, 3]
        );
        assert_eq!(
            compare(vec![0, 0, 0, 0, 0, 0], vec![0, 0, 0, 0, 0, 0]),
            vec![0, 0, 0, 0, 0, 0]
        );
        assert_eq!(compare(vec![1, 2, 3], vec![-1, -2, -3]), vec![2, 4, 6]);
        assert_eq!(
            compare(vec![1, 2, 3, 5], vec![-1, 2, 3, 4]),
            vec![2, 0, 0, 1]
        );
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/153 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn strongest_extension(class_name: &str, extensions: Vec<&str>) -> String { 

// Function to calculate the strength of an extension

fn calculate_strength(extension: &str) -> i32 {
        let cap_count = extension.chars().filter(|c| c.is_uppercase()).count() as i32;
        let sm_count = extension.chars().filter(|c| c.is_lowercase()).count() as i32;
        cap_count - sm_count
    }

    // Initialize variables to track the strongest extension
    let mut strongest = "";
    let mut max_strength = i32::MIN;

    // Iterate through each extension to find the strongest one
    for extension in extensions {
        let strength = calculate_strength(extension);
        if strength > max_strength {
            max_strength = strength;
            strongest = extension;
        }
    }

    // Return the class name concatenated with the strongest extension
    format!("{}.{}", class_name, strongest)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strongest_extension() {
        assert_eq!(
            strongest_extension("Watashi", vec!["tEN", "niNE", "eIGHt8OKe"]),
            "Watashi.eIGHt8OKe"
        );
        assert_eq!(
            strongest_extension("Boku123", vec!["nani", "NazeDa", "YEs.WeCaNe", "32145tggg"]),
            "Boku123.YEs.WeCaNe"
        );
        assert_eq!(
            strongest_extension(
                "__YESIMHERE",
                vec!["t", "eMptY", "(nothing", "zeR00", "NuLl__", "123NoooneB321"]
            ),
            "__YESIMHERE.NuLl__"
        );
        assert_eq!(
            strongest_extension("K", vec!["Ta", "TAR", "t234An", "cosSo"]),
            "K.TAR"
        );
        assert_eq!(
            strongest_extension("__HAHA", vec!["Tab", "123", "781345", "-_-"]),
            "__HAHA.123"
        );
        assert_eq!(
            strongest_extension(
                "YameRore",
                vec!["HhAas", "okIWILL123", "WorkOut", "Fails", "-_-"]
            ),
            "YameRore.okIWILL123"
        );
        assert_eq!(
            strongest_extension("finNNalLLly", vec!["Die", "NowW", "Wow", "WoW"]),
            "finNNalLLly.WoW"
        );
        assert_eq!(strongest_extension("_", vec!["Bb", "91245"]), "_.Bb");
        assert_eq!(strongest_extension("Sp", vec!["671235", "Bb"]), "Sp.671235");
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/154 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn cycpattern_check(a: &str, b: &str) -> bool {

let len = b.len();
    let mut rotated = b.to_string();

    for _ in 0..len {
        if a.contains(&rotated) {
            return true;
        }
        // Rotate the string by moving the first character to the end
        rotated.push(rotated.remove(0));
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cycpattern_check() {
        assert_eq!(cycpattern_check("xyzw", "xyw"), false);
        assert_eq!(cycpattern_check("yello", "ell"), true);
        assert_eq!(cycpattern_check("whattup", "ptut"), false);
        assert_eq!(cycpattern_check("efef", "fee"), true);
        assert_eq!(cycpattern_check("abab", "aabb"), false);
        assert_eq!(cycpattern_check("winemtt", "tinem"), true);
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_154_gen0.jsonl

Testing Rust/155 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn even_odd_count(num: i32) -> Vec<i32> {

let mut even_count = 0;
    let mut odd_count = 0;
    let mut n = num.abs(); // Handle negative numbers

    while n > 0 {
        let digit = n % 10;
        if digit % 2 == 0 {
            even_count += 1;
        } else {
            odd_count += 1;
        }
        n /= 10;
    }

    vec![even_count, odd_count]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_even_odd() {
        assert_eq!(even_odd_count(7), vec![0, 1]);
        assert_eq!(even_odd_count(-78), vec![1, 1]);
        assert_eq!(even_odd_count(3452), vec![2, 2]);
        assert_eq!(even_odd_count(346211), vec![3, 3]);
        assert_eq!(even_odd_count(-345821), vec![3, 3]);
        assert_eq!(even_odd_count(-2), vec![1, 0]);
        assert_eq!(even_odd_count(-45347), vec![2, 3]);
        assert_eq!(even_odd_count(0), vec![1, 0]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_155_gen0.jsonl

Testing Rust/156 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn int_to_mini_romank(number: i32) -> String {

fn int_to_mini_romank(number: i32) -> String {
    // Define the Roman numeral symbols and their corresponding integer values
    let roman_numerals = [
        (1000, "m"), (900, "cm"), (500, "d"), (400, "cd"),
        (100, "c"), (90, "xc"), (50, "l"), (40, "xl"),
        (10, "x"), (9, "ix"), (5, "v"), (4, "iv"),
        (1, "i")
    ];

    let mut num = number;
    let mut result = String::new();

    // Iterate through the Roman numeral symbols
    for &(value, symbol) in roman_numerals.iter() {
        while num >= value {
            num -= value;
            result.push_str(symbol);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_int_to_mini_romank() {
        assert_eq!(int_to_mini_romank(19), "xix");
        assert_eq!(int_to_mini_romank(152), "clii");
        assert_eq!(int_to_mini_romank(251), "ccli");
        assert_eq!(int_to_mini_romank(426), "cdxxvi");
        assert_eq!(int_to_mini_romank(500), "d");
        assert_eq!(int_to_mini_romank(1), "i");
        assert_eq!(int_to_mini_romank(4), "iv");
        assert_eq!(int_to_mini_romank(43), "xliii");
        assert_eq!(int_to_mini_romank(90), "xc");
        assert_eq!(int_to_mini_romank(94), "xciv");
        assert_eq!(int_to_mini_romank(532), "dxxxii");
        assert_eq!(int_to_mini_romank(900), "cm");
        assert_eq!(int_to_mini_romank(994), "cmxciv");
        assert_eq!(int_to_mini_romank(1000), "m");
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_156_gen0.jsonl

Testing Rust/157 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {

// Find the largest side, which would be the hypotenuse if it's a right-angled triangle
    let sides = [a, b, c];
    let max_side = sides.iter().cloned().fold(f32::NEG_INFINITY, f32::max);
    
    // Calculate the sum of squares of the other two sides
    let sum_of_squares = sides.iter().cloned().filter(|&x| x != max_side).map(|x| x * x).sum::<f32>();
    
    // Check if the square of the largest side is approximately equal to the sum of squares of the other two sides
    (max_side * max_side - sum_of_squares).abs() < 1e-5
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_right_angle_triangle() {
        assert_eq!(right_angle_triangle(3.0, 4.0, 5.0), true);
        assert_eq!(right_angle_triangle(1.0, 2.0, 3.0), false);
        assert_eq!(right_angle_triangle(10.0, 6.0, 8.0), true);
        assert_eq!(right_angle_triangle(2.0, 2.0, 2.0), false);
        assert_eq!(right_angle_triangle(7.0, 24.0, 25.0), true);
        assert_eq!(right_angle_triangle(10.0, 5.0, 7.0), false);
        assert_eq!(right_angle_triangle(5.0, 12.0, 13.0), true);
        assert_eq!(right_angle_triangle(15.0, 8.0, 17.0), true);
        assert_eq!(right_angle_triangle(48.0, 55.0, 73.0), true);
        assert_eq!(right_angle_triangle(1.0, 1.0, 1.0), false);
        assert_eq!(right_angle_triangle(2.0, 2.0, 10.0), false);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/158 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn find_max(words: Vec<&str>) -> &str {

words.iter().max_by(|a, b| {
        let unique_a = a.chars().collect::<HashSet<_>>().len();
        let unique_b = b.chars().collect::<HashSet<_>>().len();
        
        if unique_a == unique_b {
            a.cmp(b)
        } else {
            unique_a.cmp(&unique_b)
        }
    }).unwrap_or(&"")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_max() {
        assert_eq!(find_max(vec!["name", "of", "string"]), "string");
        assert_eq!(find_max(vec!["name", "enam", "game"]), "enam");
        assert_eq!(find_max(vec!["aaaaaaa", "bb", "cc"]), "aaaaaaa");
        assert_eq!(find_max(vec!["abc", "cba"]), "abc");
        assert_eq!(
            find_max(vec!["play", "this", "game", "of", "footbott"]),
            "footbott"
        );
        assert_eq!(find_max(vec!["we", "are", "gonna", "rock"]), "gonna");
        assert_eq!(find_max(vec!["we", "are", "a", "mad", "nation"]), "nation");
        assert_eq!(find_max(vec!["this", "is", "a", "prrk"]), "this");
        assert_eq!(find_max(vec!["b"]), "b");
        assert_eq!(find_max(vec!["play", "play", "play"]), "play");
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_158_gen0.jsonl

Testing Rust/159 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {

// Calculate how many carrots the rabbit can actually eat
    let can_eat = cmp::min(need, remaining);
    
    // Calculate the total number of carrots eaten
    let total_eaten = number + can_eat;
    
    // Calculate the number of carrots left
    let carrots_left = remaining - can_eat;
    
    // Return the result as a vector
    vec![total_eaten, carrots_left]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_eat() {
        assert_eq!(eat(5, 6, 10), vec![11, 4]);
        assert_eq!(eat(4, 8, 9), vec![12, 1]);
        assert_eq!(eat(1, 10, 10), vec![11, 0]);
        assert_eq!(eat(2, 11, 5), vec![7, 0]);
        assert_eq!(eat(4, 5, 7), vec![9, 2]);
        assert_eq!(eat(4, 5, 1), vec![5, 0]);
    }

}

-----CODE END-----
Generation 1: PASSED

Testing Rust/160 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn do_algebra(operato: Vec<&str>, operand: Vec<i32>) -> i32 {

if operators.len() != operands.len() - 1 {
        panic!("The length of operator list must be equal to the length of operand list minus one.");
    }

    let mut result = operands[0];
    let mut iter = operands.iter().skip(1).zip(operators.iter());

    for (operand, &operator) in iter {
        result = match operator {
            "+" => result + operand,
            "-" => result - operand,
            "*" => result * operand,
            "//" => {
                if *operand == 0 {
                    panic!("Division by zero is not allowed.");
                }
                result / operand
            }
            "**" => result.pow(*operand as u32),
            _ => panic!("Unsupported operator: {}", operator),
        };
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_do_algebra() {
        assert_eq!(do_algebra(vec!["**", "*", "+"], vec![2, 3, 4, 5]), 37);
        assert_eq!(do_algebra(vec!["+", "*", "-"], vec![2, 3, 4, 5]), 9);
        assert_eq!(do_algebra(vec!["//", "*"], vec![7, 3, 4]), 8);
    }


}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_160_gen0.jsonl

Testing Rust/161 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn solve_161(s: &str) -> String {

fn solve_161(s: &str) -> String {
    let mut has_letters = false;
    let mut result = String::with_capacity(s.len());

    for c in s.chars() {
        if c.is_alphabetic() {
            has_letters = true;
            if c.is_lowercase() {
                result.push(c.to_ascii_uppercase());
            } else {
                result.push(c.to_ascii_lowercase());
            }
        } else {
            result.push(c);
        }
    }

    if !has_letters {
        result = result.chars().rev().collect();
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solve_161() {
        assert_eq!(solve_161("AsDf"), "aSdF");
        assert_eq!(solve_161("1234"), "4321");
        assert_eq!(solve_161("ab"), "AB");
        assert_eq!(solve_161("#a@C"), "#A@c");
        assert_eq!(solve_161("#AsdfW^45"), "#aSDFw^45");
        assert_eq!(solve_161("#6@2"), "2@6#");
        assert_eq!(solve_161("#$a^D"), "#$A^d");
        assert_eq!(solve_161("#ccc"), "#CCC");
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_161_gen0.jsonl

Testing Rust/162 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn string_to_md5(text: &str) -> String {

if text.is_empty() {
        None
    } else {
        let hash = md5::compute(text);
        Some(format!("{:x}", hash))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_string_to_md5() {
        assert_eq!(
            string_to_md5("Hello world"),
            "3e25960a79dbc69b674cd4ec67a72c62"
        );
        assert_eq!(string_to_md5(""), "None");
        assert_eq!(string_to_md5("A B C"), "0ef78513b0cb8cef12743f5aeb35f888");
        assert_eq!(
            string_to_md5("password"),
            "5f4dcc3b5aa765d61d8327deb882cf99"
        );
    }

}

-----CODE END-----
Generation 1: failed: compilation error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_162_gen0.jsonl

Testing Rust/163 (Generation 1/1):
-----CODE BEGIN-----

fn main(){}
use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};
use rand::Rng;
use regex::Regex;
use md5;
use std::any::{Any, TypeId};

fn generate_integers(a: i32, b: i32) -> Vec<i32> {

use std::collections::HashSet;

    let (start, end) = if a <= b { (a, b) } else { (b, a) };
    let mut even_digits_set = HashSet::new();

    for num in start..=end {
        let mut n = num;
        while n > 0 {
            let digit = n % 10;
            if digit % 2 == 0 {
                even_digits_set.insert(digit);
            }
            n /= 10;
        }
    }

    let mut even_digits_vec: Vec<i32> = even_digits_set.into_iter().collect();
    even_digits_vec.sort();
    even_digits_vec
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_integers() {
        assert_eq!(generate_integers(2, 10), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(10, 2), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(132, 2), vec![2, 4, 6, 8]);
        assert_eq!(generate_integers(17, 89), vec![]);
    }

}

-----CODE END-----
Generation 1: failed: execution error
See logs at: /home/john/Thesis/Rust_CoT_Eval/rust/tmp/logs/rust_163_gen0.jsonl
Top-1 Accuracy: 64.02% (105/164)
Evaluation results saved to completions_rust_humanevalsynthesize_parsed_eval.jsonl
